var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _defaults(obj, defaults) { var keys = Object.getOwnPropertyNames(defaults); for (var i = 0; i < keys.length; i++) { var key = keys[i]; var value = Object.getOwnPropertyDescriptor(defaults, key); if (value && value.configurable && obj[key] === undefined) { Object.defineProperty(obj, key, value); } } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass); }

import b from '../builders';
import { appendChild, isLiteral, printLiteral } from '../utils';
import { Parser } from '../parser';
import SyntaxError from '../errors/syntax-error';
export var HandlebarsNodeVisitors = function (_Parser) {
    _inherits(HandlebarsNodeVisitors, _Parser);

    function HandlebarsNodeVisitors() {
        _classCallCheck(this, HandlebarsNodeVisitors);

        var _this = _possibleConstructorReturn(this, _Parser.apply(this, arguments));

        _this.cursorCount = 0;
        return _this;
    }

    HandlebarsNodeVisitors.prototype.cursor = function cursor() {
        return '%cursor:' + this.cursorCount++ + '%';
    };

    HandlebarsNodeVisitors.prototype.Program = function Program(program) {
        var body = [];
        this.cursorCount = 0;
        var node = void 0;
        if (this.isTopLevel) {
            node = b.template(body, program.blockParams, program.loc);
        } else {
            node = b.blockItself(body, program.blockParams, program.chained, program.loc);
        }
        var i = void 0,
            l = program.body.length;
        this.elementStack.push(node);
        if (l === 0) {
            return this.elementStack.pop();
        }
        for (i = 0; i < l; i++) {
            this.acceptNode(program.body[i]);
        }
        // Ensure that that the element stack is balanced properly.
        var poppedNode = this.elementStack.pop();
        if (poppedNode !== node) {
            var elementNode = poppedNode;
            throw new SyntaxError('Unclosed element `' + elementNode.tag + '` (on line ' + elementNode.loc.start.line + ').', elementNode.loc);
        }
        return node;
    };

    HandlebarsNodeVisitors.prototype.BlockStatement = function BlockStatement(block) {
        if (this.tokenizer['state'] === 'comment') {
            this.appendToCommentData(this.sourceForNode(block));
            return;
        }
        if (this.tokenizer['state'] !== 'comment' && this.tokenizer['state'] !== 'data' && this.tokenizer['state'] !== 'beforeData') {
            throw new SyntaxError('A block may only be used inside an HTML element or another block.', block.loc);
        }

        var _acceptCallNodes = acceptCallNodes(this, block),
            path = _acceptCallNodes.path,
            params = _acceptCallNodes.params,
            hash = _acceptCallNodes.hash;

        var program = this.Program(block.program);
        var inverse = block.inverse ? this.Program(block.inverse) : null;
        if (path.original === 'in-element') {
            hash = addInElementHash(this.cursor(), hash, block.loc);
        }
        var node = b.block(path, params, hash, program, inverse, block.loc);
        var parentProgram = this.currentElement();
        appendChild(parentProgram, node);
    };

    HandlebarsNodeVisitors.prototype.MustacheStatement = function MustacheStatement(rawMustache) {
        var tokenizer = this.tokenizer;

        if (tokenizer.state === 'comment') {
            this.appendToCommentData(this.sourceForNode(rawMustache));
            return;
        }
        var mustache = void 0;
        var escaped = rawMustache.escaped,
            loc = rawMustache.loc;

        if (isLiteral(rawMustache.path)) {
            mustache = {
                type: 'MustacheStatement',
                path: this.acceptNode(rawMustache.path),
                params: [],
                hash: b.hash(),
                escaped: escaped,
                loc: loc
            };
        } else {
            var _acceptCallNodes2 = acceptCallNodes(this, rawMustache),
                path = _acceptCallNodes2.path,
                params = _acceptCallNodes2.params,
                hash = _acceptCallNodes2.hash;

            mustache = b.mustache(path, params, hash, !escaped, loc);
        }
        switch (tokenizer.state) {
            // Tag helpers
            case "tagOpen" /* tagOpen */:
            case "tagName" /* tagName */:
                throw new SyntaxError('Cannot use mustaches in an elements tagname: `' + this.sourceForNode(rawMustache, rawMustache.path) + '` at L' + loc.start.line + ':C' + loc.start.column, mustache.loc);
            case "beforeAttributeName" /* beforeAttributeName */:
                addElementModifier(this.currentStartTag, mustache);
                break;
            case "attributeName" /* attributeName */:
            case "afterAttributeName" /* afterAttributeName */:
                this.beginAttributeValue(false);
                this.finishAttributeValue();
                addElementModifier(this.currentStartTag, mustache);
                tokenizer.transitionTo("beforeAttributeName" /* beforeAttributeName */);
                break;
            case "afterAttributeValueQuoted" /* afterAttributeValueQuoted */:
                addElementModifier(this.currentStartTag, mustache);
                tokenizer.transitionTo("beforeAttributeName" /* beforeAttributeName */);
                break;
            // Attribute values
            case "beforeAttributeValue" /* beforeAttributeValue */:
                this.beginAttributeValue(false);
                appendDynamicAttributeValuePart(this.currentAttribute, mustache);
                tokenizer.transitionTo("attributeValueUnquoted" /* attributeValueUnquoted */);
                break;
            case "attributeValueDoubleQuoted" /* attributeValueDoubleQuoted */:
            case "attributeValueSingleQuoted" /* attributeValueSingleQuoted */:
            case "attributeValueUnquoted" /* attributeValueUnquoted */:
                appendDynamicAttributeValuePart(this.currentAttribute, mustache);
                break;
            // TODO: Only append child when the tokenizer state makes
            // sense to do so, otherwise throw an error.
            default:
                appendChild(this.currentElement(), mustache);
        }
        return mustache;
    };

    HandlebarsNodeVisitors.prototype.ContentStatement = function ContentStatement(content) {
        updateTokenizerLocation(this.tokenizer, content);
        this.tokenizer.tokenizePart(content.value);
        this.tokenizer.flushData();
    };

    HandlebarsNodeVisitors.prototype.CommentStatement = function CommentStatement(rawComment) {
        var tokenizer = this.tokenizer;

        if (tokenizer.state === "comment" /* comment */) {
                this.appendToCommentData(this.sourceForNode(rawComment));
                return null;
            }
        var value = rawComment.value,
            loc = rawComment.loc;

        var comment = b.mustacheComment(value, loc);
        switch (tokenizer.state) {
            case "beforeAttributeName" /* beforeAttributeName */:
                this.currentStartTag.comments.push(comment);
                break;
            case "beforeData" /* beforeData */:
            case "data" /* data */:
                appendChild(this.currentElement(), comment);
                break;
            default:
                throw new SyntaxError('Using a Handlebars comment when in the `' + tokenizer['state'] + '` state is not supported: "' + comment.value + '" on line ' + loc.start.line + ':' + loc.start.column, rawComment.loc);
        }
        return comment;
    };

    HandlebarsNodeVisitors.prototype.PartialStatement = function PartialStatement(partial) {
        var loc = partial.loc;

        throw new SyntaxError('Handlebars partials are not supported: "' + this.sourceForNode(partial, partial.name) + '" at L' + loc.start.line + ':C' + loc.start.column, partial.loc);
    };

    HandlebarsNodeVisitors.prototype.PartialBlockStatement = function PartialBlockStatement(partialBlock) {
        var loc = partialBlock.loc;

        throw new SyntaxError('Handlebars partial blocks are not supported: "' + this.sourceForNode(partialBlock, partialBlock.name) + '" at L' + loc.start.line + ':C' + loc.start.column, partialBlock.loc);
    };

    HandlebarsNodeVisitors.prototype.Decorator = function Decorator(decorator) {
        var loc = decorator.loc;

        throw new SyntaxError('Handlebars decorators are not supported: "' + this.sourceForNode(decorator, decorator.path) + '" at L' + loc.start.line + ':C' + loc.start.column, decorator.loc);
    };

    HandlebarsNodeVisitors.prototype.DecoratorBlock = function DecoratorBlock(decoratorBlock) {
        var loc = decoratorBlock.loc;

        throw new SyntaxError('Handlebars decorator blocks are not supported: "' + this.sourceForNode(decoratorBlock, decoratorBlock.path) + '" at L' + loc.start.line + ':C' + loc.start.column, decoratorBlock.loc);
    };

    HandlebarsNodeVisitors.prototype.SubExpression = function SubExpression(sexpr) {
        var _acceptCallNodes3 = acceptCallNodes(this, sexpr),
            path = _acceptCallNodes3.path,
            params = _acceptCallNodes3.params,
            hash = _acceptCallNodes3.hash;

        return b.sexpr(path, params, hash, sexpr.loc);
    };

    HandlebarsNodeVisitors.prototype.PathExpression = function PathExpression(path) {
        var original = path.original,
            loc = path.loc;

        var parts = void 0;
        if (original.indexOf('/') !== -1) {
            if (original.slice(0, 2) === './') {
                throw new SyntaxError('Using "./" is not supported in Glimmer and unnecessary: "' + path.original + '" on line ' + loc.start.line + '.', path.loc);
            }
            if (original.slice(0, 3) === '../') {
                throw new SyntaxError('Changing context using "../" is not supported in Glimmer: "' + path.original + '" on line ' + loc.start.line + '.', path.loc);
            }
            if (original.indexOf('.') !== -1) {
                throw new SyntaxError('Mixing \'.\' and \'/\' in paths is not supported in Glimmer; use only \'.\' to separate property paths: "' + path.original + '" on line ' + loc.start.line + '.', path.loc);
            }
            parts = [path.parts.join('/')];
        } else if (original === '.') {
            var locationInfo = 'L' + loc.start.line + ':C' + loc.start.column;
            throw new SyntaxError('\'.\' is not a supported path in Glimmer; check for a path with a trailing \'.\' at ' + locationInfo + '.', path.loc);
        } else {
            parts = path.parts;
        }
        var thisHead = false;
        // This is to fix a bug in the Handlebars AST where the path expressions in
        // `{{this.foo}}` (and similarly `{{foo-bar this.foo named=this.foo}}` etc)
        // are simply turned into `{{foo}}`. The fix is to push it back onto the
        // parts array and let the runtime see the difference. However, we cannot
        // simply use the string `this` as it means literally the property called
        // "this" in the current context (it can be expressed in the syntax as
        // `{{[this]}}`, where the square bracket are generally for this kind of
        // escaping â€“ such as `{{foo.["bar.baz"]}}` would mean lookup a property
        // named literally "bar.baz" on `this.foo`). By convention, we use `null`
        // for this purpose.
        if (original.match(/^this(\..+)?$/)) {
            thisHead = true;
        }
        return {
            type: 'PathExpression',
            original: path.original,
            this: thisHead,
            parts: parts,
            data: path.data,
            loc: path.loc
        };
    };

    HandlebarsNodeVisitors.prototype.Hash = function Hash(hash) {
        var pairs = [];
        for (var i = 0; i < hash.pairs.length; i++) {
            var pair = hash.pairs[i];
            pairs.push(b.pair(pair.key, this.acceptNode(pair.value), pair.loc));
        }
        return b.hash(pairs, hash.loc);
    };

    HandlebarsNodeVisitors.prototype.StringLiteral = function StringLiteral(string) {
        return b.literal('StringLiteral', string.value, string.loc);
    };

    HandlebarsNodeVisitors.prototype.BooleanLiteral = function BooleanLiteral(boolean) {
        return b.literal('BooleanLiteral', boolean.value, boolean.loc);
    };

    HandlebarsNodeVisitors.prototype.NumberLiteral = function NumberLiteral(number) {
        return b.literal('NumberLiteral', number.value, number.loc);
    };

    HandlebarsNodeVisitors.prototype.UndefinedLiteral = function UndefinedLiteral(undef) {
        return b.literal('UndefinedLiteral', undefined, undef.loc);
    };

    HandlebarsNodeVisitors.prototype.NullLiteral = function NullLiteral(nul) {
        return b.literal('NullLiteral', null, nul.loc);
    };

    _createClass(HandlebarsNodeVisitors, [{
        key: 'isTopLevel',
        get: function get() {
            return this.elementStack.length === 0;
        }
    }]);

    return HandlebarsNodeVisitors;
}(Parser);
function calculateRightStrippedOffsets(original, value) {
    if (value === '') {
        // if it is empty, just return the count of newlines
        // in original
        return {
            lines: original.split('\n').length - 1,
            columns: 0
        };
    }
    // otherwise, return the number of newlines prior to
    // `value`
    var difference = original.split(value)[0];
    var lines = difference.split(/\n/);
    var lineCount = lines.length - 1;
    return {
        lines: lineCount,
        columns: lines[lineCount].length
    };
}
function updateTokenizerLocation(tokenizer, content) {
    var line = content.loc.start.line;
    var column = content.loc.start.column;
    var offsets = calculateRightStrippedOffsets(content.original, content.value);
    line = line + offsets.lines;
    if (offsets.lines) {
        column = offsets.columns;
    } else {
        column = column + offsets.columns;
    }
    tokenizer.line = line;
    tokenizer.column = column;
}
function acceptCallNodes(compiler, node) {
    var path = compiler.PathExpression(node.path);
    var params = node.params ? node.params.map(function (e) {
        return compiler.acceptNode(e);
    }) : [];
    var hash = node.hash ? compiler.Hash(node.hash) : b.hash();
    return { path: path, params: params, hash: hash };
}
function addElementModifier(element, mustache) {
    var path = mustache.path,
        params = mustache.params,
        hash = mustache.hash,
        loc = mustache.loc;

    if (isLiteral(path)) {
        var _modifier = '{{' + printLiteral(path) + '}}';
        var tag = '<' + element.name + ' ... ' + _modifier + ' ...';
        throw new SyntaxError('In ' + tag + ', ' + _modifier + ' is not a valid modifier: "' + path.original + '" on line ' + (loc && loc.start.line) + '.', mustache.loc);
    }
    var modifier = b.elementModifier(path, params, hash, loc);
    element.modifiers.push(modifier);
}
function addInElementHash(cursor, hash, loc) {
    var hasInsertBefore = false;
    hash.pairs.forEach(function (pair) {
        if (pair.key === 'guid') {
            throw new SyntaxError('Cannot pass `guid` from user space', loc);
        }
        if (pair.key === 'insertBefore') {
            hasInsertBefore = true;
        }
    });
    var guid = b.literal('StringLiteral', cursor);
    var guidPair = b.pair('guid', guid);
    hash.pairs.unshift(guidPair);
    if (!hasInsertBefore) {
        var undefinedLiteral = b.literal('UndefinedLiteral', undefined);
        var beforeSibling = b.pair('insertBefore', undefinedLiteral);
        hash.pairs.push(beforeSibling);
    }
    return hash;
}
function appendDynamicAttributeValuePart(attribute, part) {
    attribute.isDynamic = true;
    attribute.parts.push(part);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3N5bnRheC9saWIvcGFyc2VyL2hhbmRsZWJhcnMtbm9kZS12aXNpdG9ycy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQUEsT0FBQSxDQUFBLE1BQUEsYUFBQTtBQUNBLFNBQUEsV0FBQSxFQUFBLFNBQUEsRUFBQSxZQUFBLFFBQUEsVUFBQTtBQUdBLFNBQUEsTUFBQSxRQUFBLFdBQUE7QUFDQSxPQUFBLFdBQUEsTUFBQSx3QkFBQTtBQUtBLFdBQU0sc0JBQU47QUFBQTs7QUFBQSxzQ0FBQTtBQUFBOztBQUFBLHFELDhCQUFBOztBQUtFLGNBQUEsV0FBQSxHQUFBLENBQUE7QUFMRjtBQWtXQzs7QUFsV0QscUNBT0UsTUFQRixxQkFPUTtBQUNKLDRCQUFrQixLQUFsQixXQUFrQixFQUFsQjtBQUNELEtBVEg7O0FBQUEscUNBa0JFLE9BbEJGLG9CQWtCRSxPQWxCRixFQWtCOEI7QUFDMUIsWUFBSSxPQUFKLEVBQUE7QUFDQSxhQUFBLFdBQUEsR0FBQSxDQUFBO0FBRUEsWUFBQSxhQUFBO0FBRUEsWUFBSSxLQUFKLFVBQUEsRUFBcUI7QUFDbkIsbUJBQU8sRUFBQSxRQUFBLENBQUEsSUFBQSxFQUFpQixRQUFqQixXQUFBLEVBQXNDLFFBQTdDLEdBQU8sQ0FBUDtBQURGLFNBQUEsTUFFTztBQUNMLG1CQUFPLEVBQUEsV0FBQSxDQUFBLElBQUEsRUFBb0IsUUFBcEIsV0FBQSxFQUF5QyxRQUF6QyxPQUFBLEVBQTBELFFBQWpFLEdBQU8sQ0FBUDtBQUNEO0FBRUQsWUFBQSxVQUFBO0FBQUEsWUFDRSxJQUFJLFFBQUEsSUFBQSxDQUROLE1BQUE7QUFHQSxhQUFBLFlBQUEsQ0FBQSxJQUFBLENBQUEsSUFBQTtBQUVBLFlBQUksTUFBSixDQUFBLEVBQWE7QUFDWCxtQkFBTyxLQUFBLFlBQUEsQ0FBUCxHQUFPLEVBQVA7QUFDRDtBQUVELGFBQUssSUFBTCxDQUFBLEVBQVksSUFBWixD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ZixJQUFlLENBQWY7QUFDQSxTQUFBLEtBQUEsQ0FBQSxPQUFBLENBQUEsUUFBQTtBQUVBLFFBQUksQ0FBSixlQUFBLEVBQXNCO0FBQ3BCLFlBQUksbUJBQW1CLEVBQUEsT0FBQSxDQUFBLGtCQUFBLEVBQXZCLFNBQXVCLENBQXZCO0FBQ0EsWUFBSSxnQkFBZ0IsRUFBQSxJQUFBLENBQUEsY0FBQSxFQUFwQixnQkFBb0IsQ0FBcEI7QUFDQSxhQUFBLEtBQUEsQ0FBQSxJQUFBLENBQUEsYUFBQTtBQUNEO0FBRUQsV0FBQSxJQUFBO0FBQ0Q7QUFFRCxTQUFBLCtCQUFBLENBQUEsU0FBQSxFQUFBLElBQUEsRUFBMEY7QUFDeEYsY0FBQSxTQUFBLEdBQUEsSUFBQTtBQUNBLGNBQUEsS0FBQSxDQUFBLElBQUEsQ0FBQSxJQUFBO0FBQ0QiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgYiBmcm9tICcuLi9idWlsZGVycyc7XG5pbXBvcnQgeyBhcHBlbmRDaGlsZCwgaXNMaXRlcmFsLCBwcmludExpdGVyYWwgfSBmcm9tICcuLi91dGlscyc7XG5pbXBvcnQgKiBhcyBBU1QgZnJvbSAnLi4vdHlwZXMvbm9kZXMnO1xuaW1wb3J0ICogYXMgSEJTIGZyb20gJy4uL3R5cGVzL2hhbmRsZWJhcnMtYXN0JztcbmltcG9ydCB7IFBhcnNlciwgVGFnLCBBdHRyaWJ1dGUgfSBmcm9tICcuLi9wYXJzZXInO1xuaW1wb3J0IFN5bnRheEVycm9yIGZyb20gJy4uL2Vycm9ycy9zeW50YXgtZXJyb3InO1xuaW1wb3J0IHsgT3B0aW9uIH0gZnJvbSAnQGdsaW1tZXIvdXRpbCc7XG5pbXBvcnQgeyBSZWNhc3QgfSBmcm9tICdAZ2xpbW1lci9pbnRlcmZhY2VzJztcbmltcG9ydCB7IFRva2VuaXplclN0YXRlIH0gZnJvbSAnc2ltcGxlLWh0bWwtdG9rZW5pemVyJztcblxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEhhbmRsZWJhcnNOb2RlVmlzaXRvcnMgZXh0ZW5kcyBQYXJzZXIge1xuICBhYnN0cmFjdCBhcHBlbmRUb0NvbW1lbnREYXRhKHM6IHN0cmluZyk6IHZvaWQ7XG4gIGFic3RyYWN0IGJlZ2luQXR0cmlidXRlVmFsdWUocXVvdGVkOiBib29sZWFuKTogdm9pZDtcbiAgYWJzdHJhY3QgZmluaXNoQXR0cmlidXRlVmFsdWUoKTogdm9pZDtcblxuICBjdXJzb3JDb3VudCA9IDA7XG5cbiAgY3Vyc29yKCkge1xuICAgIHJldHVybiBgJWN1cnNvcjoke3RoaXMuY3Vyc29yQ291bnQrK30lYDtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0IGlzVG9wTGV2ZWwoKSB7XG4gICAgcmV0dXJuIHRoaXMuZWxlbWVudFN0YWNrLmxlbmd0aCA9PT0gMDtcbiAgfVxuXG4gIFByb2dyYW0ocHJvZ3JhbTogSEJTLlByb2dyYW0pOiBBU1QuQmxvY2s7XG4gIFByb2dyYW0ocHJvZ3JhbTogSEJTLlByb2dyYW0pOiBBU1QuVGVtcGxhdGU7XG4gIFByb2dyYW0ocHJvZ3JhbTogSEJTLlByb2dyYW0pOiBBU1QuVGVtcGxhdGUgfCBBU1QuQmxvY2s7XG4gIFByb2dyYW0ocHJvZ3JhbTogSEJTLlByb2dyYW0pOiBBU1QuQmxvY2sgfCBBU1QuVGVtcGxhdGUge1xuICAgIGxldCBib2R5OiBBU1QuU3RhdGVtZW50W10gPSBbXTtcbiAgICB0aGlzLmN1cnNvckNvdW50ID0gMDtcblxuICAgIGxldCBub2RlO1xuXG4gICAgaWYgKHRoaXMuaXNUb3BMZXZlbCkge1xuICAgICAgbm9kZSA9IGIudGVtcGxhdGUoYm9keSwgcHJvZ3JhbS5ibG9ja1BhcmFtcywgcHJvZ3JhbS5sb2MpO1xuICAgIH0gZWxzZSB7XG4gICAgICBub2RlID0gYi5ibG9ja0l0c2VsZihib2R5LCBwcm9ncmFtLmJsb2NrUGFyYW1zLCBwcm9ncmFtLmNoYWluZWQsIHByb2dyYW0ubG9jKTtcbiAgICB9XG5cbiAgICBsZXQgaSxcbiAgICAgIGwgPSBwcm9ncmFtLmJvZHkubGVuZ3RoO1xuXG4gICAgdGhpcy5lbGVtZW50U3RhY2sucHVzaChub2RlKTtcblxuICAgIGlmIChsID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5lbGVtZW50U3RhY2sucG9wKCkgYXMgQVNULkJsb2NrIHwgQVNULlRlbXBsYXRlO1xuICAgIH1cblxuICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIHRoaXMuYWNjZXB0Tm9kZShwcm9ncmFtLmJvZHlbaV0pO1xuICAgIH1cblxuICAgIC8vIEVuc3VyZSB0aGF0IHRoYXQgdGhlIGVsZW1lbnQgc3RhY2sgaXMgYmFsYW5jZWQgcHJvcGVybHkuXG4gICAgbGV0IHBvcHBlZE5vZGUgPSB0aGlzLmVsZW1lbnRTdGFjay5wb3AoKTtcbiAgICBpZiAocG9wcGVkTm9kZSAhPT0gbm9kZSkge1xuICAgICAgbGV0IGVsZW1lbnROb2RlID0gcG9wcGVkTm9kZSBhcyBBU1QuRWxlbWVudE5vZGU7XG5cbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcbiAgICAgICAgJ1VuY2xvc2VkIGVsZW1lbnQgYCcgKyBlbGVtZW50Tm9kZS50YWcgKyAnYCAob24gbGluZSAnICsgZWxlbWVudE5vZGUubG9jIS5zdGFydC5saW5lICsgJykuJyxcbiAgICAgICAgZWxlbWVudE5vZGUubG9jXG4gICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9XG5cbiAgQmxvY2tTdGF0ZW1lbnQoYmxvY2s6IEhCUy5CbG9ja1N0YXRlbWVudCk6IEFTVC5CbG9ja1N0YXRlbWVudCB8IHZvaWQge1xuICAgIGlmICh0aGlzLnRva2VuaXplclsnc3RhdGUnXSA9PT0gJ2NvbW1lbnQnKSB7XG4gICAgICB0aGlzLmFwcGVuZFRvQ29tbWVudERhdGEodGhpcy5zb3VyY2VGb3JOb2RlKGJsb2NrKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKFxuICAgICAgdGhpcy50b2tlbml6ZXJbJ3N0YXRlJ10gIT09ICdjb21tZW50JyAmJlxuICAgICAgdGhpcy50b2tlbml6ZXJbJ3N0YXRlJ10gIT09ICdkYXRhJyAmJlxuICAgICAgdGhpcy50b2tlbml6ZXJbJ3N0YXRlJ10gIT09ICdiZWZvcmVEYXRhJ1xuICAgICkge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFxuICAgICAgICAnQSBibG9jayBtYXkgb25seSBiZSB1c2VkIGluc2lkZSBhbiBIVE1MIGVsZW1lbnQgb3IgYW5vdGhlciBibG9jay4nLFxuICAgICAgICBibG9jay5sb2NcbiAgICAgICk7XG4gICAgfVxuXG4gICAgbGV0IHsgcGF0aCwgcGFyYW1zLCBoYXNoIH0gPSBhY2NlcHRDYWxsTm9kZXModGhpcywgYmxvY2spO1xuICAgIGxldCBwcm9ncmFtID0gdGhpcy5Qcm9ncmFtKGJsb2NrLnByb2dyYW0pO1xuICAgIGxldCBpbnZlcnNlID0gYmxvY2suaW52ZXJzZSA/IHRoaXMuUHJvZ3JhbShibG9jay5pbnZlcnNlKSA6IG51bGw7XG5cbiAgICBpZiAocGF0aC5vcmlnaW5hbCA9PT0gJ2luLWVsZW1lbnQnKSB7XG4gICAgICBoYXNoID0gYWRkSW5FbGVtZW50SGFzaCh0aGlzLmN1cnNvcigpLCBoYXNoLCBibG9jay5sb2MpO1xuICAgIH1cblxuICAgIGxldCBub2RlID0gYi5ibG9jayhwYXRoLCBwYXJhbXMsIGhhc2gsIHByb2dyYW0sIGludmVyc2UsIGJsb2NrLmxvYyk7XG5cbiAgICBsZXQgcGFyZW50UHJvZ3JhbSA9IHRoaXMuY3VycmVudEVsZW1lbnQoKTtcblxuICAgIGFwcGVuZENoaWxkKHBhcmVudFByb2dyYW0sIG5vZGUpO1xuICB9XG5cbiAgTXVzdGFjaGVTdGF0ZW1lbnQocmF3TXVzdGFjaGU6IEhCUy5NdXN0YWNoZVN0YXRlbWVudCk6IEFTVC5NdXN0YWNoZVN0YXRlbWVudCB8IHZvaWQge1xuICAgIGxldCB7IHRva2VuaXplciB9ID0gdGhpcztcblxuICAgIGlmICh0b2tlbml6ZXIuc3RhdGUgPT09ICdjb21tZW50Jykge1xuICAgICAgdGhpcy5hcHBlbmRUb0NvbW1lbnREYXRhKHRoaXMuc291cmNlRm9yTm9kZShyYXdNdXN0YWNoZSkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCBtdXN0YWNoZTogQVNULk11c3RhY2hlU3RhdGVtZW50O1xuICAgIGxldCB7IGVzY2FwZWQsIGxvYyB9ID0gcmF3TXVzdGFjaGU7XG5cbiAgICBpZiAoaXNMaXRlcmFsKHJhd011c3RhY2hlLnBhdGgpKSB7XG4gICAgICBtdXN0YWNoZSA9IHtcbiAgICAgICAgdHlwZTogJ011c3RhY2hlU3RhdGVtZW50JyxcbiAgICAgICAgcGF0aDogdGhpcy5hY2NlcHROb2RlPEFTVC5MaXRlcmFsPihyYXdNdXN0YWNoZS5wYXRoKSxcbiAgICAgICAgcGFyYW1zOiBbXSxcbiAgICAgICAgaGFzaDogYi5oYXNoKCksXG4gICAgICAgIGVzY2FwZWQsXG4gICAgICAgIGxvYyxcbiAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCB7IHBhdGgsIHBhcmFtcywgaGFzaCB9ID0gYWNjZXB0Q2FsbE5vZGVzKHRoaXMsIHJhd011c3RhY2hlIGFzIEhCUy5NdXN0YWNoZVN0YXRlbWVudCAmIHtcbiAgICAgICAgcGF0aDogSEJTLlBhdGhFeHByZXNzaW9uO1xuICAgICAgfSk7XG4gICAgICBtdXN0YWNoZSA9IGIubXVzdGFjaGUocGF0aCwgcGFyYW1zLCBoYXNoLCAhZXNjYXBlZCwgbG9jKTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHRva2VuaXplci5zdGF0ZSkge1xuICAgICAgLy8gVGFnIGhlbHBlcnNcbiAgICAgIGNhc2UgVG9rZW5pemVyU3RhdGUudGFnT3BlbjpcbiAgICAgIGNhc2UgVG9rZW5pemVyU3RhdGUudGFnTmFtZTpcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFxuICAgICAgICAgIGBDYW5ub3QgdXNlIG11c3RhY2hlcyBpbiBhbiBlbGVtZW50cyB0YWduYW1lOiBcXGAke3RoaXMuc291cmNlRm9yTm9kZShcbiAgICAgICAgICAgIHJhd011c3RhY2hlLFxuICAgICAgICAgICAgcmF3TXVzdGFjaGUucGF0aFxuICAgICAgICAgICl9XFxgIGF0IEwke2xvYy5zdGFydC5saW5lfTpDJHtsb2Muc3RhcnQuY29sdW1ufWAsXG4gICAgICAgICAgbXVzdGFjaGUubG9jXG4gICAgICAgICk7XG5cbiAgICAgIGNhc2UgVG9rZW5pemVyU3RhdGUuYmVmb3JlQXR0cmlidXRlTmFtZTpcbiAgICAgICAgYWRkRWxlbWVudE1vZGlmaWVyKHRoaXMuY3VycmVudFN0YXJ0VGFnLCBtdXN0YWNoZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUb2tlbml6ZXJTdGF0ZS5hdHRyaWJ1dGVOYW1lOlxuICAgICAgY2FzZSBUb2tlbml6ZXJTdGF0ZS5hZnRlckF0dHJpYnV0ZU5hbWU6XG4gICAgICAgIHRoaXMuYmVnaW5BdHRyaWJ1dGVWYWx1ZShmYWxzZSk7XG4gICAgICAgIHRoaXMuZmluaXNoQXR0cmlidXRlVmFsdWUoKTtcbiAgICAgICAgYWRkRWxlbWVudE1vZGlmaWVyKHRoaXMuY3VycmVudFN0YXJ0VGFnLCBtdXN0YWNoZSk7XG4gICAgICAgIHRva2VuaXplci50cmFuc2l0aW9uVG8oVG9rZW5pemVyU3RhdGUuYmVmb3JlQXR0cmlidXRlTmFtZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUb2tlbml6ZXJTdGF0ZS5hZnRlckF0dHJpYnV0ZVZhbHVlUXVvdGVkOlxuICAgICAgICBhZGRFbGVtZW50TW9kaWZpZXIodGhpcy5jdXJyZW50U3RhcnRUYWcsIG11c3RhY2hlKTtcbiAgICAgICAgdG9rZW5pemVyLnRyYW5zaXRpb25UbyhUb2tlbml6ZXJTdGF0ZS5iZWZvcmVBdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIC8vIEF0dHJpYnV0ZSB2YWx1ZXNcbiAgICAgIGNhc2UgVG9rZW5pemVyU3RhdGUuYmVmb3JlQXR0cmlidXRlVmFsdWU6XG4gICAgICAgIHRoaXMuYmVnaW5BdHRyaWJ1dGVWYWx1ZShmYWxzZSk7XG4gICAgICAgIGFwcGVuZER5bmFtaWNBdHRyaWJ1dGVWYWx1ZVBhcnQodGhpcy5jdXJyZW50QXR0cmlidXRlISwgbXVzdGFjaGUpO1xuICAgICAgICB0b2tlbml6ZXIudHJhbnNpdGlvblRvKFRva2VuaXplclN0YXRlLmF0dHJpYnV0ZVZhbHVlVW5xdW90ZWQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgVG9rZW5pemVyU3RhdGUuYXR0cmlidXRlVmFsdWVEb3VibGVRdW90ZWQ6XG4gICAgICBjYXNlIFRva2VuaXplclN0YXRlLmF0dHJpYnV0ZVZhbHVlU2luZ2xlUXVvdGVkOlxuICAgICAgY2FzZSBUb2tlbml6ZXJTdGF0ZS5hdHRyaWJ1dGVWYWx1ZVVucXVvdGVkOlxuICAgICAgICBhcHBlbmREeW5hbWljQXR0cmlidXRlVmFsdWVQYXJ0KHRoaXMuY3VycmVudEF0dHJpYnV0ZSEsIG11c3RhY2hlKTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIC8vIFRPRE86IE9ubHkgYXBwZW5kIGNoaWxkIHdoZW4gdGhlIHRva2VuaXplciBzdGF0ZSBtYWtlc1xuICAgICAgLy8gc2Vuc2UgdG8gZG8gc28sIG90aGVyd2lzZSB0aHJvdyBhbiBlcnJvci5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGFwcGVuZENoaWxkKHRoaXMuY3VycmVudEVsZW1lbnQoKSwgbXVzdGFjaGUpO1xuICAgIH1cblxuICAgIHJldHVybiBtdXN0YWNoZTtcbiAgfVxuXG4gIENvbnRlbnRTdGF0ZW1lbnQoY29udGVudDogSEJTLkNvbnRlbnRTdGF0ZW1lbnQpOiB2b2lkIHtcbiAgICB1cGRhdGVUb2tlbml6ZXJMb2NhdGlvbih0aGlzLnRva2VuaXplciwgY29udGVudCk7XG5cbiAgICB0aGlzLnRva2VuaXplci50b2tlbml6ZVBhcnQoY29udGVudC52YWx1ZSk7XG4gICAgdGhpcy50b2tlbml6ZXIuZmx1c2hEYXRhKCk7XG4gIH1cblxuICBDb21tZW50U3RhdGVtZW50KHJhd0NvbW1lbnQ6IEhCUy5Db21tZW50U3RhdGVtZW50KTogT3B0aW9uPEFTVC5NdXN0YWNoZUNvbW1lbnRTdGF0ZW1lbnQ+IHtcbiAgICBsZXQgeyB0b2tlbml6ZXIgfSA9IHRoaXM7XG5cbiAgICBpZiAodG9rZW5pemVyLnN0YXRlID09PSBUb2tlbml6ZXJTdGF0ZS5jb21tZW50KSB7XG4gICAgICB0aGlzLmFwcGVuZFRvQ29tbWVudERhdGEodGhpcy5zb3VyY2VGb3JOb2RlKHJhd0NvbW1lbnQpKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIGxldCB7IHZhbHVlLCBsb2MgfSA9IHJhd0NvbW1lbnQ7XG4gICAgbGV0IGNvbW1lbnQgPSBiLm11c3RhY2hlQ29tbWVudCh2YWx1ZSwgbG9jKTtcblxuICAgIHN3aXRjaCAodG9rZW5pemVyLnN0YXRlKSB7XG4gICAgICBjYXNlIFRva2VuaXplclN0YXRlLmJlZm9yZUF0dHJpYnV0ZU5hbWU6XG4gICAgICAgIHRoaXMuY3VycmVudFN0YXJ0VGFnLmNvbW1lbnRzLnB1c2goY29tbWVudCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFRva2VuaXplclN0YXRlLmJlZm9yZURhdGE6XG4gICAgICBjYXNlIFRva2VuaXplclN0YXRlLmRhdGE6XG4gICAgICAgIGFwcGVuZENoaWxkKHRoaXMuY3VycmVudEVsZW1lbnQoKSwgY29tbWVudCk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXG4gICAgICAgICAgYFVzaW5nIGEgSGFuZGxlYmFycyBjb21tZW50IHdoZW4gaW4gdGhlIFxcYCR7XG4gICAgICAgICAgICB0b2tlbml6ZXJbJ3N0YXRlJ11cbiAgICAgICAgICB9XFxgIHN0YXRlIGlzIG5vdCBzdXBwb3J0ZWQ6IFwiJHtjb21tZW50LnZhbHVlfVwiIG9uIGxpbmUgJHtsb2Muc3RhcnQubGluZX06JHtcbiAgICAgICAgICAgIGxvYy5zdGFydC5jb2x1bW5cbiAgICAgICAgICB9YCxcbiAgICAgICAgICByYXdDb21tZW50LmxvY1xuICAgICAgICApO1xuICAgIH1cblxuICAgIHJldHVybiBjb21tZW50O1xuICB9XG5cbiAgUGFydGlhbFN0YXRlbWVudChwYXJ0aWFsOiBIQlMuUGFydGlhbFN0YXRlbWVudCk6IG5ldmVyIHtcbiAgICBsZXQgeyBsb2MgfSA9IHBhcnRpYWw7XG5cbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXG4gICAgICBgSGFuZGxlYmFycyBwYXJ0aWFscyBhcmUgbm90IHN1cHBvcnRlZDogXCIke3RoaXMuc291cmNlRm9yTm9kZShwYXJ0aWFsLCBwYXJ0aWFsLm5hbWUpfVwiIGF0IEwke1xuICAgICAgICBsb2Muc3RhcnQubGluZVxuICAgICAgfTpDJHtsb2Muc3RhcnQuY29sdW1ufWAsXG4gICAgICBwYXJ0aWFsLmxvY1xuICAgICk7XG4gIH1cblxuICBQYXJ0aWFsQmxvY2tTdGF0ZW1lbnQocGFydGlhbEJsb2NrOiBIQlMuUGFydGlhbEJsb2NrU3RhdGVtZW50KTogbmV2ZXIge1xuICAgIGxldCB7IGxvYyB9ID0gcGFydGlhbEJsb2NrO1xuXG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFxuICAgICAgYEhhbmRsZWJhcnMgcGFydGlhbCBibG9ja3MgYXJlIG5vdCBzdXBwb3J0ZWQ6IFwiJHt0aGlzLnNvdXJjZUZvck5vZGUoXG4gICAgICAgIHBhcnRpYWxCbG9jayxcbiAgICAgICAgcGFydGlhbEJsb2NrLm5hbWVcbiAgICAgICl9XCIgYXQgTCR7bG9jLnN0YXJ0LmxpbmV9OkMke2xvYy5zdGFydC5jb2x1bW59YCxcbiAgICAgIHBhcnRpYWxCbG9jay5sb2NcbiAgICApO1xuICB9XG5cbiAgRGVjb3JhdG9yKGRlY29yYXRvcjogSEJTLkRlY29yYXRvcik6IG5ldmVyIHtcbiAgICBsZXQgeyBsb2MgfSA9IGRlY29yYXRvcjtcblxuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcbiAgICAgIGBIYW5kbGViYXJzIGRlY29yYXRvcnMgYXJlIG5vdCBzdXBwb3J0ZWQ6IFwiJHt0aGlzLnNvdXJjZUZvck5vZGUoXG4gICAgICAgIGRlY29yYXRvcixcbiAgICAgICAgZGVjb3JhdG9yLnBhdGhcbiAgICAgICl9XCIgYXQgTCR7bG9jLnN0YXJ0LmxpbmV9OkMke2xvYy5zdGFydC5jb2x1bW59YCxcbiAgICAgIGRlY29yYXRvci5sb2NcbiAgICApO1xuICB9XG5cbiAgRGVjb3JhdG9yQmxvY2soZGVjb3JhdG9yQmxvY2s6IEhCUy5EZWNvcmF0b3JCbG9jayk6IG5ldmVyIHtcbiAgICBsZXQgeyBsb2MgfSA9IGRlY29yYXRvckJsb2NrO1xuXG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFxuICAgICAgYEhhbmRsZWJhcnMgZGVjb3JhdG9yIGJsb2NrcyBhcmUgbm90IHN1cHBvcnRlZDogXCIke3RoaXMuc291cmNlRm9yTm9kZShcbiAgICAgICAgZGVjb3JhdG9yQmxvY2ssXG4gICAgICAgIGRlY29yYXRvckJsb2NrLnBhdGhcbiAgICAgICl9XCIgYXQgTCR7bG9jLnN0YXJ0LmxpbmV9OkMke2xvYy5zdGFydC5jb2x1bW59YCxcbiAgICAgIGRlY29yYXRvckJsb2NrLmxvY1xuICAgICk7XG4gIH1cblxuICBTdWJFeHByZXNzaW9uKHNleHByOiBIQlMuU3ViRXhwcmVzc2lvbik6IEFTVC5TdWJFeHByZXNzaW9uIHtcbiAgICBsZXQgeyBwYXRoLCBwYXJhbXMsIGhhc2ggfSA9IGFjY2VwdENhbGxOb2Rlcyh0aGlzLCBzZXhwcik7XG4gICAgcmV0dXJuIGIuc2V4cHIocGF0aCwgcGFyYW1zLCBoYXNoLCBzZXhwci5sb2MpO1xuICB9XG5cbiAgUGF0aEV4cHJlc3Npb24ocGF0aDogSEJTLlBhdGhFeHByZXNzaW9uKTogQVNULlBhdGhFeHByZXNzaW9uIHtcbiAgICBsZXQgeyBvcmlnaW5hbCwgbG9jIH0gPSBwYXRoO1xuICAgIGxldCBwYXJ0czogc3RyaW5nW107XG5cbiAgICBpZiAob3JpZ2luYWwuaW5kZXhPZignLycpICE9PSAtMSkge1xuICAgICAgaWYgKG9yaWdpbmFsLnNsaWNlKDAsIDIpID09PSAnLi8nKSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcbiAgICAgICAgICBgVXNpbmcgXCIuL1wiIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2xpbW1lciBhbmQgdW5uZWNlc3Nhcnk6IFwiJHtwYXRoLm9yaWdpbmFsfVwiIG9uIGxpbmUgJHtcbiAgICAgICAgICAgIGxvYy5zdGFydC5saW5lXG4gICAgICAgICAgfS5gLFxuICAgICAgICAgIHBhdGgubG9jXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAob3JpZ2luYWwuc2xpY2UoMCwgMykgPT09ICcuLi8nKSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcbiAgICAgICAgICBgQ2hhbmdpbmcgY29udGV4dCB1c2luZyBcIi4uL1wiIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2xpbW1lcjogXCIke3BhdGgub3JpZ2luYWx9XCIgb24gbGluZSAke1xuICAgICAgICAgICAgbG9jLnN0YXJ0LmxpbmVcbiAgICAgICAgICB9LmAsXG4gICAgICAgICAgcGF0aC5sb2NcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcmlnaW5hbC5pbmRleE9mKCcuJykgIT09IC0xKSB7XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcbiAgICAgICAgICBgTWl4aW5nICcuJyBhbmQgJy8nIGluIHBhdGhzIGlzIG5vdCBzdXBwb3J0ZWQgaW4gR2xpbW1lcjsgdXNlIG9ubHkgJy4nIHRvIHNlcGFyYXRlIHByb3BlcnR5IHBhdGhzOiBcIiR7XG4gICAgICAgICAgICBwYXRoLm9yaWdpbmFsXG4gICAgICAgICAgfVwiIG9uIGxpbmUgJHtsb2Muc3RhcnQubGluZX0uYCxcbiAgICAgICAgICBwYXRoLmxvY1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgcGFydHMgPSBbcGF0aC5wYXJ0cy5qb2luKCcvJyldO1xuICAgIH0gZWxzZSBpZiAob3JpZ2luYWwgPT09ICcuJykge1xuICAgICAgbGV0IGxvY2F0aW9uSW5mbyA9IGBMJHtsb2Muc3RhcnQubGluZX06QyR7bG9jLnN0YXJ0LmNvbHVtbn1gO1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFxuICAgICAgICBgJy4nIGlzIG5vdCBhIHN1cHBvcnRlZCBwYXRoIGluIEdsaW1tZXI7IGNoZWNrIGZvciBhIHBhdGggd2l0aCBhIHRyYWlsaW5nICcuJyBhdCAke2xvY2F0aW9uSW5mb30uYCxcbiAgICAgICAgcGF0aC5sb2NcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhcnRzID0gcGF0aC5wYXJ0cztcbiAgICB9XG5cbiAgICBsZXQgdGhpc0hlYWQgPSBmYWxzZTtcblxuICAgIC8vIFRoaXMgaXMgdG8gZml4IGEgYnVnIGluIHRoZSBIYW5kbGViYXJzIEFTVCB3aGVyZSB0aGUgcGF0aCBleHByZXNzaW9ucyBpblxuICAgIC8vIGB7e3RoaXMuZm9vfX1gIChhbmQgc2ltaWxhcmx5IGB7e2Zvby1iYXIgdGhpcy5mb28gbmFtZWQ9dGhpcy5mb299fWAgZXRjKVxuICAgIC8vIGFyZSBzaW1wbHkgdHVybmVkIGludG8gYHt7Zm9vfX1gLiBUaGUgZml4IGlzIHRvIHB1c2ggaXQgYmFjayBvbnRvIHRoZVxuICAgIC8vIHBhcnRzIGFycmF5IGFuZCBsZXQgdGhlIHJ1bnRpbWUgc2VlIHRoZSBkaWZmZXJlbmNlLiBIb3dldmVyLCB3ZSBjYW5ub3RcbiAgICAvLyBzaW1wbHkgdXNlIHRoZSBzdHJpbmcgYHRoaXNgIGFzIGl0IG1lYW5zIGxpdGVyYWxseSB0aGUgcHJvcGVydHkgY2FsbGVkXG4gICAgLy8gXCJ0aGlzXCIgaW4gdGhlIGN1cnJlbnQgY29udGV4dCAoaXQgY2FuIGJlIGV4cHJlc3NlZCBpbiB0aGUgc3ludGF4IGFzXG4gICAgLy8gYHt7W3RoaXNdfX1gLCB3aGVyZSB0aGUgc3F1YXJlIGJyYWNrZXQgYXJlIGdlbmVyYWxseSBmb3IgdGhpcyBraW5kIG9mXG4gICAgLy8gZXNjYXBpbmcg4oCTIHN1Y2ggYXMgYHt7Zm9vLltcImJhci5iYXpcIl19fWAgd291bGQgbWVhbiBsb29rdXAgYSBwcm9wZXJ0eVxuICAgIC8vIG5hbWVkIGxpdGVyYWxseSBcImJhci5iYXpcIiBvbiBgdGhpcy5mb29gKS4gQnkgY29udmVudGlvbiwgd2UgdXNlIGBudWxsYFxuICAgIC8vIGZvciB0aGlzIHB1cnBvc2UuXG4gICAgaWYgKG9yaWdpbmFsLm1hdGNoKC9edGhpcyhcXC4uKyk/JC8pKSB7XG4gICAgICB0aGlzSGVhZCA9IHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdQYXRoRXhwcmVzc2lvbicsXG4gICAgICBvcmlnaW5hbDogcGF0aC5vcmlnaW5hbCxcbiAgICAgIHRoaXM6IHRoaXNIZWFkLFxuICAgICAgcGFydHMsXG4gICAgICBkYXRhOiBwYXRoLmRhdGEsXG4gICAgICBsb2M6IHBhdGgubG9jLFxuICAgIH07XG4gIH1cblxuICBIYXNoKGhhc2g6IEhCUy5IYXNoKTogQVNULkhhc2gge1xuICAgIGxldCBwYWlyczogQVNULkhhc2hQYWlyW10gPSBbXTtcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaGFzaC5wYWlycy5sZW5ndGg7IGkrKykge1xuICAgICAgbGV0IHBhaXIgPSBoYXNoLnBhaXJzW2ldO1xuICAgICAgcGFpcnMucHVzaChiLnBhaXIocGFpci5rZXksIHRoaXMuYWNjZXB0Tm9kZShwYWlyLnZhbHVlKSwgcGFpci5sb2MpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYi5oYXNoKHBhaXJzLCBoYXNoLmxvYyk7XG4gIH1cblxuICBTdHJpbmdMaXRlcmFsKHN0cmluZzogSEJTLlN0cmluZ0xpdGVyYWwpOiBBU1QuU3RyaW5nTGl0ZXJhbCB7XG4gICAgcmV0dXJuIGIubGl0ZXJhbCgnU3RyaW5nTGl0ZXJhbCcsIHN0cmluZy52YWx1ZSwgc3RyaW5nLmxvYyk7XG4gIH1cblxuICBCb29sZWFuTGl0ZXJhbChib29sZWFuOiBIQlMuQm9vbGVhbkxpdGVyYWwpOiBBU1QuQm9vbGVhbkxpdGVyYWwge1xuICAgIHJldHVybiBiLmxpdGVyYWwoJ0Jvb2xlYW5MaXRlcmFsJywgYm9vbGVhbi52YWx1ZSwgYm9vbGVhbi5sb2MpO1xuICB9XG5cbiAgTnVtYmVyTGl0ZXJhbChudW1iZXI6IEhCUy5OdW1iZXJMaXRlcmFsKTogQVNULk51bWJlckxpdGVyYWwge1xuICAgIHJldHVybiBiLmxpdGVyYWwoJ051bWJlckxpdGVyYWwnLCBudW1iZXIudmFsdWUsIG51bWJlci5sb2MpO1xuICB9XG5cbiAgVW5kZWZpbmVkTGl0ZXJhbCh1bmRlZjogSEJTLlVuZGVmaW5lZExpdGVyYWwpOiBBU1QuVW5kZWZpbmVkTGl0ZXJhbCB7XG4gICAgcmV0dXJuIGIubGl0ZXJhbCgnVW5kZWZpbmVkTGl0ZXJhbCcsIHVuZGVmaW5lZCwgdW5kZWYubG9jKTtcbiAgfVxuXG4gIE51bGxMaXRlcmFsKG51bDogSEJTLk51bGxMaXRlcmFsKTogQVNULk51bGxMaXRlcmFsIHtcbiAgICByZXR1cm4gYi5saXRlcmFsKCdOdWxsTGl0ZXJhbCcsIG51bGwsIG51bC5sb2MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGN1bGF0ZVJpZ2h0U3RyaXBwZWRPZmZzZXRzKG9yaWdpbmFsOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcpIHtcbiAgaWYgKHZhbHVlID09PSAnJykge1xuICAgIC8vIGlmIGl0IGlzIGVtcHR5LCBqdXN0IHJldHVybiB0aGUgY291bnQgb2YgbmV3bGluZXNcbiAgICAvLyBpbiBvcmlnaW5hbFxuICAgIHJldHVybiB7XG4gICAgICBsaW5lczogb3JpZ2luYWwuc3BsaXQoJ1xcbicpLmxlbmd0aCAtIDEsXG4gICAgICBjb2x1bW5zOiAwLFxuICAgIH07XG4gIH1cblxuICAvLyBvdGhlcndpc2UsIHJldHVybiB0aGUgbnVtYmVyIG9mIG5ld2xpbmVzIHByaW9yIHRvXG4gIC8vIGB2YWx1ZWBcbiAgbGV0IGRpZmZlcmVuY2UgPSBvcmlnaW5hbC5zcGxpdCh2YWx1ZSlbMF07XG4gIGxldCBsaW5lcyA9IGRpZmZlcmVuY2Uuc3BsaXQoL1xcbi8pO1xuICBsZXQgbGluZUNvdW50ID0gbGluZXMubGVuZ3RoIC0gMTtcblxuICByZXR1cm4ge1xuICAgIGxpbmVzOiBsaW5lQ291bnQsXG4gICAgY29sdW1uczogbGluZXNbbGluZUNvdW50XS5sZW5ndGgsXG4gIH07XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZVRva2VuaXplckxvY2F0aW9uKHRva2VuaXplcjogUGFyc2VyWyd0b2tlbml6ZXInXSwgY29udGVudDogSEJTLkNvbnRlbnRTdGF0ZW1lbnQpIHtcbiAgbGV0IGxpbmUgPSBjb250ZW50LmxvYy5zdGFydC5saW5lO1xuICBsZXQgY29sdW1uID0gY29udGVudC5sb2Muc3RhcnQuY29sdW1uO1xuXG4gIGxldCBvZmZzZXRzID0gY2FsY3VsYXRlUmlnaHRTdHJpcHBlZE9mZnNldHMoXG4gICAgY29udGVudC5vcmlnaW5hbCBhcyBSZWNhc3Q8SEJTLlN0cmlwRmxhZ3MsIHN0cmluZz4sXG4gICAgY29udGVudC52YWx1ZVxuICApO1xuXG4gIGxpbmUgPSBsaW5lICsgb2Zmc2V0cy5saW5lcztcbiAgaWYgKG9mZnNldHMubGluZXMpIHtcbiAgICBjb2x1bW4gPSBvZmZzZXRzLmNvbHVtbnM7XG4gIH0gZWxzZSB7XG4gICAgY29sdW1uID0gY29sdW1uICsgb2Zmc2V0cy5jb2x1bW5zO1xuICB9XG5cbiAgdG9rZW5pemVyLmxpbmUgPSBsaW5lO1xuICB0b2tlbml6ZXIuY29sdW1uID0gY29sdW1uO1xufVxuXG5mdW5jdGlvbiBhY2NlcHRDYWxsTm9kZXMoXG4gIGNvbXBpbGVyOiBIYW5kbGViYXJzTm9kZVZpc2l0b3JzLFxuICBub2RlOiB7XG4gICAgcGF0aDogSEJTLlBhdGhFeHByZXNzaW9uO1xuICAgIHBhcmFtczogSEJTLkV4cHJlc3Npb25bXTtcbiAgICBoYXNoOiBIQlMuSGFzaDtcbiAgfVxuKTogeyBwYXRoOiBBU1QuUGF0aEV4cHJlc3Npb247IHBhcmFtczogQVNULkV4cHJlc3Npb25bXTsgaGFzaDogQVNULkhhc2ggfSB7XG4gIGxldCBwYXRoID0gY29tcGlsZXIuUGF0aEV4cHJlc3Npb24obm9kZS5wYXRoKTtcblxuICBsZXQgcGFyYW1zID0gbm9kZS5wYXJhbXMgPyBub2RlLnBhcmFtcy5tYXAoZSA9PiBjb21waWxlci5hY2NlcHROb2RlPEFTVC5FeHByZXNzaW9uPihlKSkgOiBbXTtcbiAgbGV0IGhhc2ggPSBub2RlLmhhc2ggPyBjb21waWxlci5IYXNoKG5vZGUuaGFzaCkgOiBiLmhhc2goKTtcblxuICByZXR1cm4geyBwYXRoLCBwYXJhbXMsIGhhc2ggfTtcbn1cblxuZnVuY3Rpb24gYWRkRWxlbWVudE1vZGlmaWVyKGVsZW1lbnQ6IFRhZzwnU3RhcnRUYWcnPiwgbXVzdGFjaGU6IEFTVC5NdXN0YWNoZVN0YXRlbWVudCkge1xuICBsZXQgeyBwYXRoLCBwYXJhbXMsIGhhc2gsIGxvYyB9ID0gbXVzdGFjaGU7XG5cbiAgaWYgKGlzTGl0ZXJhbChwYXRoKSkge1xuICAgIGxldCBtb2RpZmllciA9IGB7eyR7cHJpbnRMaXRlcmFsKHBhdGgpfX19YDtcbiAgICBsZXQgdGFnID0gYDwke2VsZW1lbnQubmFtZX0gLi4uICR7bW9kaWZpZXJ9IC4uLmA7XG5cbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXG4gICAgICBgSW4gJHt0YWd9LCAke21vZGlmaWVyfSBpcyBub3QgYSB2YWxpZCBtb2RpZmllcjogXCIke3BhdGgub3JpZ2luYWx9XCIgb24gbGluZSAke2xvYyAmJlxuICAgICAgICBsb2Muc3RhcnQubGluZX0uYCxcbiAgICAgIG11c3RhY2hlLmxvY1xuICAgICk7XG4gIH1cblxuICBsZXQgbW9kaWZpZXIgPSBiLmVsZW1lbnRNb2RpZmllcihwYXRoLCBwYXJhbXMsIGhhc2gsIGxvYyk7XG4gIGVsZW1lbnQubW9kaWZpZXJzLnB1c2gobW9kaWZpZXIpO1xufVxuXG5mdW5jdGlvbiBhZGRJbkVsZW1lbnRIYXNoKGN1cnNvcjogc3RyaW5nLCBoYXNoOiBBU1QuSGFzaCwgbG9jOiBBU1QuU291cmNlTG9jYXRpb24pIHtcbiAgbGV0IGhhc0luc2VydEJlZm9yZSA9IGZhbHNlO1xuICBoYXNoLnBhaXJzLmZvckVhY2gocGFpciA9PiB7XG4gICAgaWYgKHBhaXIua2V5ID09PSAnZ3VpZCcpIHtcbiAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcignQ2Fubm90IHBhc3MgYGd1aWRgIGZyb20gdXNlciBzcGFjZScsIGxvYyk7XG4gICAgfVxuXG4gICAgaWYgKHBhaXIua2V5ID09PSAnaW5zZXJ0QmVmb3JlJykge1xuICAgICAgaGFzSW5zZXJ0QmVmb3JlID0gdHJ1ZTtcbiAgICB9XG4gIH0pO1xuXG4gIGxldCBndWlkID0gYi5saXRlcmFsKCdTdHJpbmdMaXRlcmFsJywgY3Vyc29yKTtcbiAgbGV0IGd1aWRQYWlyID0gYi5wYWlyKCdndWlkJywgZ3VpZCk7XG4gIGhhc2gucGFpcnMudW5zaGlmdChndWlkUGFpcik7XG5cbiAgaWYgKCFoYXNJbnNlcnRCZWZvcmUpIHtcbiAgICBsZXQgdW5kZWZpbmVkTGl0ZXJhbCA9IGIubGl0ZXJhbCgnVW5kZWZpbmVkTGl0ZXJhbCcsIHVuZGVmaW5lZCk7XG4gICAgbGV0IGJlZm9yZVNpYmxpbmcgPSBiLnBhaXIoJ2luc2VydEJlZm9yZScsIHVuZGVmaW5lZExpdGVyYWwpO1xuICAgIGhhc2gucGFpcnMucHVzaChiZWZvcmVTaWJsaW5nKTtcbiAgfVxuXG4gIHJldHVybiBoYXNoO1xufVxuXG5mdW5jdGlvbiBhcHBlbmREeW5hbWljQXR0cmlidXRlVmFsdWVQYXJ0KGF0dHJpYnV0ZTogQXR0cmlidXRlLCBwYXJ0OiBBU1QuTXVzdGFjaGVTdGF0ZW1lbnQpIHtcbiAgYXR0cmlidXRlLmlzRHluYW1pYyA9IHRydWU7XG4gIGF0dHJpYnV0ZS5wYXJ0cy5wdXNoKHBhcnQpO1xufVxuIl0sInNvdXJjZVJvb3QiOiIifQ==