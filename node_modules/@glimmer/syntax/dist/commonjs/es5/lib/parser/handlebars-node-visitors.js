"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.HandlebarsNodeVisitors = undefined;

var _builders = require("../builders");

var _builders2 = _interopRequireDefault(_builders);

var _utils = require("../utils");

var _parser = require("../parser");

var _syntaxError = require("../errors/syntax-error");

var _syntaxError2 = _interopRequireDefault(_syntaxError);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var _createClass = function () {
    function defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
            var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
        }
    }return function (Constructor, protoProps, staticProps) {
        if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
}();

function _defaults(obj, defaults) {
    var keys = Object.getOwnPropertyNames(defaults);for (var i = 0; i < keys.length; i++) {
        var key = keys[i];var value = Object.getOwnPropertyDescriptor(defaults, key);if (value && value.configurable && obj[key] === undefined) {
            Object.defineProperty(obj, key, value);
        }
    }return obj;
}

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}

function _possibleConstructorReturn(self, call) {
    if (!self) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }return call && (typeof call === "object" || typeof call === "function") ? call : self;
}

function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } });if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : _defaults(subClass, superClass);
}

var HandlebarsNodeVisitors = exports.HandlebarsNodeVisitors = function (_Parser) {
    _inherits(HandlebarsNodeVisitors, _Parser);

    function HandlebarsNodeVisitors() {
        _classCallCheck(this, HandlebarsNodeVisitors);

        var _this = _possibleConstructorReturn(this, _Parser.apply(this, arguments));

        _this.cursorCount = 0;
        return _this;
    }

    HandlebarsNodeVisitors.prototype.cursor = function cursor() {
        return '%cursor:' + this.cursorCount++ + '%';
    };

    HandlebarsNodeVisitors.prototype.Program = function Program(program) {
        var body = [];
        this.cursorCount = 0;
        var node = void 0;
        if (this.isTopLevel) {
            node = _builders2.default.template(body, program.blockParams, program.loc);
        } else {
            node = _builders2.default.blockItself(body, program.blockParams, program.chained, program.loc);
        }
        var i = void 0,
            l = program.body.length;
        this.elementStack.push(node);
        if (l === 0) {
            return this.elementStack.pop();
        }
        for (i = 0; i < l; i++) {
            this.acceptNode(program.body[i]);
        }
        // Ensure that that the element stack is balanced properly.
        var poppedNode = this.elementStack.pop();
        if (poppedNode !== node) {
            var elementNode = poppedNode;
            throw new _syntaxError2.default('Unclosed element `' + elementNode.tag + '` (on line ' + elementNode.loc.start.line + ').', elementNode.loc);
        }
        return node;
    };

    HandlebarsNodeVisitors.prototype.BlockStatement = function BlockStatement(block) {
        if (this.tokenizer['state'] === 'comment') {
            this.appendToCommentData(this.sourceForNode(block));
            return;
        }
        if (this.tokenizer['state'] !== 'comment' && this.tokenizer['state'] !== 'data' && this.tokenizer['state'] !== 'beforeData') {
            throw new _syntaxError2.default('A block may only be used inside an HTML element or another block.', block.loc);
        }

        var _acceptCallNodes = acceptCallNodes(this, block),
            path = _acceptCallNodes.path,
            params = _acceptCallNodes.params,
            hash = _acceptCallNodes.hash;

        var program = this.Program(block.program);
        var inverse = block.inverse ? this.Program(block.inverse) : null;
        if (path.original === 'in-element') {
            hash = addInElementHash(this.cursor(), hash, block.loc);
        }
        var node = _builders2.default.block(path, params, hash, program, inverse, block.loc);
        var parentProgram = this.currentElement();
        (0, _utils.appendChild)(parentProgram, node);
    };

    HandlebarsNodeVisitors.prototype.MustacheStatement = function MustacheStatement(rawMustache) {
        var tokenizer = this.tokenizer;

        if (tokenizer.state === 'comment') {
            this.appendToCommentData(this.sourceForNode(rawMustache));
            return;
        }
        var mustache = void 0;
        var escaped = rawMustache.escaped,
            loc = rawMustache.loc;

        if ((0, _utils.isLiteral)(rawMustache.path)) {
            mustache = {
                type: 'MustacheStatement',
                path: this.acceptNode(rawMustache.path),
                params: [],
                hash: _builders2.default.hash(),
                escaped: escaped,
                loc: loc
            };
        } else {
            var _acceptCallNodes2 = acceptCallNodes(this, rawMustache),
                path = _acceptCallNodes2.path,
                params = _acceptCallNodes2.params,
                hash = _acceptCallNodes2.hash;

            mustache = _builders2.default.mustache(path, params, hash, !escaped, loc);
        }
        switch (tokenizer.state) {
            // Tag helpers
            case "tagOpen" /* tagOpen */:
            case "tagName" /* tagName */:
                throw new _syntaxError2.default('Cannot use mustaches in an elements tagname: `' + this.sourceForNode(rawMustache, rawMustache.path) + '` at L' + loc.start.line + ':C' + loc.start.column, mustache.loc);
            case "beforeAttributeName" /* beforeAttributeName */:
                addElementModifier(this.currentStartTag, mustache);
                break;
            case "attributeName" /* attributeName */:
            case "afterAttributeName" /* afterAttributeName */:
                this.beginAttributeValue(false);
                this.finishAttributeValue();
                addElementModifier(this.currentStartTag, mustache);
                tokenizer.transitionTo("beforeAttributeName" /* beforeAttributeName */);
                break;
            case "afterAttributeValueQuoted" /* afterAttributeValueQuoted */:
                addElementModifier(this.currentStartTag, mustache);
                tokenizer.transitionTo("beforeAttributeName" /* beforeAttributeName */);
                break;
            // Attribute values
            case "beforeAttributeValue" /* beforeAttributeValue */:
                this.beginAttributeValue(false);
                appendDynamicAttributeValuePart(this.currentAttribute, mustache);
                tokenizer.transitionTo("attributeValueUnquoted" /* attributeValueUnquoted */);
                break;
            case "attributeValueDoubleQuoted" /* attributeValueDoubleQuoted */:
            case "attributeValueSingleQuoted" /* attributeValueSingleQuoted */:
            case "attributeValueUnquoted" /* attributeValueUnquoted */:
                appendDynamicAttributeValuePart(this.currentAttribute, mustache);
                break;
            // TODO: Only append child when the tokenizer state makes
            // sense to do so, otherwise throw an error.
            default:
                (0, _utils.appendChild)(this.currentElement(), mustache);
        }
        return mustache;
    };

    HandlebarsNodeVisitors.prototype.ContentStatement = function ContentStatement(content) {
        updateTokenizerLocation(this.tokenizer, content);
        this.tokenizer.tokenizePart(content.value);
        this.tokenizer.flushData();
    };

    HandlebarsNodeVisitors.prototype.CommentStatement = function CommentStatement(rawComment) {
        var tokenizer = this.tokenizer;

        if (tokenizer.state === "comment" /* comment */) {
                this.appendToCommentData(this.sourceForNode(rawComment));
                return null;
            }
        var value = rawComment.value,
            loc = rawComment.loc;

        var comment = _builders2.default.mustacheComment(value, loc);
        switch (tokenizer.state) {
            case "beforeAttributeName" /* beforeAttributeName */:
                this.currentStartTag.comments.push(comment);
                break;
            case "beforeData" /* beforeData */:
            case "data" /* data */:
                (0, _utils.appendChild)(this.currentElement(), comment);
                break;
            default:
                throw new _syntaxError2.default('Using a Handlebars comment when in the `' + tokenizer['state'] + '` state is not supported: "' + comment.value + '" on line ' + loc.start.line + ':' + loc.start.column, rawComment.loc);
        }
        return comment;
    };

    HandlebarsNodeVisitors.prototype.PartialStatement = function PartialStatement(partial) {
        var loc = partial.loc;

        throw new _syntaxError2.default('Handlebars partials are not supported: "' + this.sourceForNode(partial, partial.name) + '" at L' + loc.start.line + ':C' + loc.start.column, partial.loc);
    };

    HandlebarsNodeVisitors.prototype.PartialBlockStatement = function PartialBlockStatement(partialBlock) {
        var loc = partialBlock.loc;

        throw new _syntaxError2.default('Handlebars partial blocks are not supported: "' + this.sourceForNode(partialBlock, partialBlock.name) + '" at L' + loc.start.line + ':C' + loc.start.column, partialBlock.loc);
    };

    HandlebarsNodeVisitors.prototype.Decorator = function Decorator(decorator) {
        var loc = decorator.loc;

        throw new _syntaxError2.default('Handlebars decorators are not supported: "' + this.sourceForNode(decorator, decorator.path) + '" at L' + loc.start.line + ':C' + loc.start.column, decorator.loc);
    };

    HandlebarsNodeVisitors.prototype.DecoratorBlock = function DecoratorBlock(decoratorBlock) {
        var loc = decoratorBlock.loc;

        throw new _syntaxError2.default('Handlebars decorator blocks are not supported: "' + this.sourceForNode(decoratorBlock, decoratorBlock.path) + '" at L' + loc.start.line + ':C' + loc.start.column, decoratorBlock.loc);
    };

    HandlebarsNodeVisitors.prototype.SubExpression = function SubExpression(sexpr) {
        var _acceptCallNodes3 = acceptCallNodes(this, sexpr),
            path = _acceptCallNodes3.path,
            params = _acceptCallNodes3.params,
            hash = _acceptCallNodes3.hash;

        return _builders2.default.sexpr(path, params, hash, sexpr.loc);
    };

    HandlebarsNodeVisitors.prototype.PathExpression = function PathExpression(path) {
        var original = path.original,
            loc = path.loc;

        var parts = void 0;
        if (original.indexOf('/') !== -1) {
            if (original.slice(0, 2) === './') {
                throw new _syntaxError2.default('Using "./" is not supported in Glimmer and unnecessary: "' + path.original + '" on line ' + loc.start.line + '.', path.loc);
            }
            if (original.slice(0, 3) === '../') {
                throw new _syntaxError2.default('Changing context using "../" is not supported in Glimmer: "' + path.original + '" on line ' + loc.start.line + '.', path.loc);
            }
            if (original.indexOf('.') !== -1) {
                throw new _syntaxError2.default('Mixing \'.\' and \'/\' in paths is not supported in Glimmer; use only \'.\' to separate property paths: "' + path.original + '" on line ' + loc.start.line + '.', path.loc);
            }
            parts = [path.parts.join('/')];
        } else if (original === '.') {
            var locationInfo = 'L' + loc.start.line + ':C' + loc.start.column;
            throw new _syntaxError2.default('\'.\' is not a supported path in Glimmer; check for a path with a trailing \'.\' at ' + locationInfo + '.', path.loc);
        } else {
            parts = path.parts;
        }
        var thisHead = false;
        // This is to fix a bug in the Handlebars AST where the path expressions in
        // `{{this.foo}}` (and similarly `{{foo-bar this.foo named=this.foo}}` etc)
        // are simply turned into `{{foo}}`. The fix is to push it back onto the
        // parts array and let the runtime see the difference. However, we cannot
        // simply use the string `this` as it means literally the property called
        // "this" in the current context (it can be expressed in the syntax as
        // `{{[this]}}`, where the square bracket are generally for this kind of
        // escaping – such as `{{foo.["bar.baz"]}}` would mean lookup a property
        // named literally "bar.baz" on `this.foo`). By convention, we use `null`
        // for this purpose.
        if (original.match(/^this(\..+)?$/)) {
            thisHead = true;
        }
        return {
            type: 'PathExpression',
            original: path.original,
            this: thisHead,
            parts: parts,
            data: path.data,
            loc: path.loc
        };
    };

    HandlebarsNodeVisitors.prototype.Hash = function Hash(hash) {
        var pairs = [];
        for (var i = 0; i < hash.pairs.length; i++) {
            var pair = hash.pairs[i];
            pairs.push(_builders2.default.pair(pair.key, this.acceptNode(pair.value), pair.loc));
        }
        return _builders2.default.hash(pairs, hash.loc);
    };

    HandlebarsNodeVisitors.prototype.StringLiteral = function StringLiteral(string) {
        return _builders2.default.literal('StringLiteral', string.value, string.loc);
    };

    HandlebarsNodeVisitors.prototype.BooleanLiteral = function BooleanLiteral(boolean) {
        return _builders2.default.literal('BooleanLiteral', boolean.value, boolean.loc);
    };

    HandlebarsNodeVisitors.prototype.NumberLiteral = function NumberLiteral(number) {
        return _builders2.default.literal('NumberLiteral', number.value, number.loc);
    };

    HandlebarsNodeVisitors.prototype.UndefinedLiteral = function UndefinedLiteral(undef) {
        return _builders2.default.literal('UndefinedLiteral', undefined, undef.loc);
    };

    HandlebarsNodeVisitors.prototype.NullLiteral = function NullLiteral(nul) {
        return _builders2.default.literal('NullLiteral', null, nul.loc);
    };

    _createClass(HandlebarsNodeVisitors, [{
        key: 'isTopLevel',
        get: function get() {
            return this.elementStack.length === 0;
        }
    }]);

    return HandlebarsNodeVisitors;
}(_parser.Parser);
function calculateRightStrippedOffsets(original, value) {
    if (value === '') {
        // if it is empty, just return the count of newlines
        // in original
        return {
            lines: original.split('\n').length - 1,
            columns: 0
        };
    }
    // otherwise, return the number of newlines prior to
    // `value`
    var difference = original.split(value)[0];
    var lines = difference.split(/\n/);
    var lineCount = lines.length - 1;
    return {
        lines: lineCount,
        columns: lines[lineCount].length
    };
}
function updateTokenizerLocation(tokenizer, content) {
    var line = content.loc.start.line;
    var column = content.loc.start.column;
    var offsets = calculateRightStrippedOffsets(content.original, content.value);
    line = line + offsets.lines;
    if (offsets.lines) {
        column = offsets.columns;
    } else {
        column = column + offsets.columns;
    }
    tokenizer.line = line;
    tokenizer.column = column;
}
function acceptCallNodes(compiler, node) {
    var path = compiler.PathExpression(node.path);
    var params = node.params ? node.params.map(function (e) {
        return compiler.acceptNode(e);
    }) : [];
    var hash = node.hash ? compiler.Hash(node.hash) : _builders2.default.hash();
    return { path: path, params: params, hash: hash };
}
function addElementModifier(element, mustache) {
    var path = mustache.path,
        params = mustache.params,
        hash = mustache.hash,
        loc = mustache.loc;

    if ((0, _utils.isLiteral)(path)) {
        var _modifier = '{{' + (0, _utils.printLiteral)(path) + '}}';
        var tag = '<' + element.name + ' ... ' + _modifier + ' ...';
        throw new _syntaxError2.default('In ' + tag + ', ' + _modifier + ' is not a valid modifier: "' + path.original + '" on line ' + (loc && loc.start.line) + '.', mustache.loc);
    }
    var modifier = _builders2.default.elementModifier(path, params, hash, loc);
    element.modifiers.push(modifier);
}
function addInElementHash(cursor, hash, loc) {
    var hasInsertBefore = false;
    hash.pairs.forEach(function (pair) {
        if (pair.key === 'guid') {
            throw new _syntaxError2.default('Cannot pass `guid` from user space', loc);
        }
        if (pair.key === 'insertBefore') {
            hasInsertBefore = true;
        }
    });
    var guid = _builders2.default.literal('StringLiteral', cursor);
    var guidPair = _builders2.default.pair('guid', guid);
    hash.pairs.unshift(guidPair);
    if (!hasInsertBefore) {
        var undefinedLiteral = _builders2.default.literal('UndefinedLiteral', undefined);
        var beforeSibling = _builders2.default.pair('insertBefore', undefinedLiteral);
        hash.pairs.push(beforeSibling);
    }
    return hash;
}
function appendDynamicAttributeValuePart(attribute, part) {
    attribute.isDynamic = true;
    attribute.parts.push(part);
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3BhY2thZ2VzL0BnbGltbWVyL3N5bnRheC9saWIvcGFyc2VyL2hhbmRsZWJhcnMtbm9kZS12aXNpdG9ycy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQUE7Ozs7QUFDQTs7QUFHQTs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBS0EsSUFBQSwwREFBQSxVQUFBLE9BQUEsRUFBQTtBQUFBLGNBQUEsc0JBQUEsRUFBQSxPQUFBOztBQUFBLGFBQUEsc0JBQUEsR0FBQTtBQUFBLHdCQUFBLElBQUEsRUFBQSxzQkFBQTs7QUFBQSxZQUFBLFFBQUEsMkJBQUEsSUFBQSxFLG9CQUFBLFMsQ0FBQSxDQUFBOztBQUtFLGNBQUEsV0FBQSxHQUFBLENBQUE7QUFMRixlQUFBLEtBQUE7QUFrV0M7O0FBbFdELDJCQUFBLFNBQUEsQ0FBQSxNQUFBLEdBQUEsU0FBQSxNQUFBLEdBT1E7QUFDSixlQUFBLGFBQWtCLEtBQWxCLFdBQWtCLEVBQWxCLEdBQUEsR0FBQTtBQVJKLEtBQUE7O0FBQUEsMkJBQUEsU0FBQSxDQUFBLE9BQUEsR0FBQSxTQUFBLE9BQUEsQ0FBQSxPQUFBLEVBa0I4QjtBQUMxQixZQUFJLE9BQUosRUFBQTtBQUNBLGFBQUEsV0FBQSxHQUFBLENBQUE7QUFFQSxZQUFBLE9BQUEsS0FBQSxDQUFBO0FBRUEsWUFBSSxLQUFKLFVBQUEsRUFBcUI7QUFDbkIsbUJBQU8sbUJBQUEsUUFBQSxDQUFBLElBQUEsRUFBaUIsUUFBakIsV0FBQSxFQUFzQyxRQUE3QyxHQUFPLENBQVA7QUFERixTQUFBLE1BRU87QUFDTCxtQkFBTyxtQkFBQSxXQUFBLENBQUEsSUFBQSxFQUFvQixRQUFwQixXQUFBLEVBQXlDLFFBQXpDLE9BQUEsRUFBMEQsUUFBakUsR0FBTyxDQUFQO0FBQ0Q7QUFFRCxZQUFBLElBQUEsS0FBQSxDQUFBO0FBQUEsWUFDRSxJQUFJLFFBQUEsSUFBQSxDQUROLE1BQUE7QUFHQSxhQUFBLFlBQUEsQ0FBQSxJQUFBLENBQUEsSUFBQTtBQUVBLFlBQUksTUFBSixDQUFBLEVBQWE7QUFDWCxtQkFBTyxLQUFBLFlBQUEsQ0FBUCxHQUFPLEVBQVA7QUFDRDtBQUVELGFBQUssSUFBTCxDQUFBLEVBQVksSUFBWixDQUFBLEVBQUEsR0FBQSxFQUF3QjtBQUN0QixpQkFBQSxVQUFBLENBQWdCLFFBQUEsSUFBQSxDQUFoQixDQUFnQixDQUFoQjtBQUNEO0FBRUQ7QUFDQSxZQUFJLGFBQWEsS0FBQSxZQUFBLENBQWpCLEdBQWlCLEVBQWpCO0FBQ0EsWUFBSSxlQUFKLElBQUEsRUFBeUI7QUFDdkIsZ0JBQUksY0FBSixVQUFBO0FBRUEsa0JBQU0sSUFBQSxxQkFBQSxDQUNKLHVCQUF1QixZQUF2QixHQUFBLEdBQUEsYUFBQSxHQUF5RCxZQUFBLEdBQUEsQ0FBQSxLQUFBLENBQXpELElBQUEsR0FESSxJQUFBLEVBRUosWUFGRixHQUFNLENBQU47QUFJRDtBQUVELGVBQUEsSUFBQTtBQXRESixLQUFBOztBQUFBLDJCQUFBLFNBQUEsQ0FBQSxjQUFBLEdBQUEsU0FBQSxjQUFBLENBQUEsS0FBQSxFQXlEMEM7QUFDdEMsWUFBSSxLQUFBLFNBQUEsQ0FBQSxPQUFBLE1BQUosU0FBQSxFQUEyQztBQUN6QyxpQkFBQSxtQkFBQSxDQUF5QixLQUFBLGFBQUEsQ0FBekIsS0FBeUIsQ0FBekI7QUFDQTtBQUNEO0FBRUQsWUFDRSxLQUFBLFNBQUEsQ0FBQSxPQUFBLE1BQUEsU0FBQSxJQUNBLEtBQUEsU0FBQSxDQUFBLE9BQUEsTUFEQSxNQUFBLElBRUEsS0FBQSxTQUFBLENBQUEsT0FBQSxNQUhGLFlBQUEsRUFJRTtBQUNBLGtCQUFNLElBQUEscUJBQUEsQ0FBQSxtRUFBQSxFQUVKLE1BRkYsR0FBTSxDQUFOO0FBSUQ7O0FBZnFDLFlBQUEsbUJBaUJULGdCQUFBLElBQUEsRUFqQlMsS0FpQlQsQ0FqQlM7QUFBQSxZQUFBLE9BQUEsaUJBQUEsSUFBQTtBQUFBLFlBQUEsU0FBQSxpQkFBQSxNQUFBO0FBQUEsWUFBQSxPQUFBLGlCQUFBLElBQUE7O0FBa0J0QyxZQUFJLFVBQVUsS0FBQSxPQUFBLENBQWEsTUFBM0IsT0FBYyxDQUFkO0FBQ0EsWUFBSSxVQUFVLE1BQUEsT0FBQSxHQUFnQixLQUFBLE9BQUEsQ0FBYSxNQUE3QixPQUFnQixDQUFoQixHQUFkLElBQUE7QUFFQSxZQUFJLEtBQUEsUUFBQSxLQUFKLFlBQUEsRUFBb0M7QUFDbEMsbUJBQU8saUJBQWlCLEtBQWpCLE1BQWlCLEVBQWpCLEVBQUEsSUFBQSxFQUFzQyxNQUE3QyxHQUFPLENBQVA7QUFDRDtBQUVELFlBQUksT0FBTyxtQkFBQSxLQUFBLENBQUEsSUFBQSxFQUFBLE1BQUEsRUFBQSxJQUFBLEVBQUEsT0FBQSxFQUFBLE9BQUEsRUFBOEMsTUFBekQsR0FBVyxDQUFYO0FBRUEsWUFBSSxnQkFBZ0IsS0FBcEIsY0FBb0IsRUFBcEI7QUFFQSxnQ0FBQSxhQUFBLEVBQUEsSUFBQTtBQXRGSixLQUFBOztBQUFBLDJCQUFBLFNBQUEsQ0FBQSxpQkFBQSxHQUFBLFNBQUEsaUJBQUEsQ0FBQSxXQUFBLEVBeUZzRDtBQUFBLFlBQUEsWUFBQSxLQUFBLFNBQUE7O0FBR2xELFlBQUksVUFBQSxLQUFBLEtBQUosU0FBQSxFQUFtQztBQUNqQyxpQkFBQSxtQkFBQSxDQUF5QixLQUFBLGFBQUEsQ0FBekIsV0FBeUIsQ0FBekI7QUFDQTtBQUNEO0FBRUQsWUFBQSxXQUFBLEtBQUEsQ0FBQTtBQVJrRCxZQUFBLFVBQUEsWUFBQSxPQUFBO0FBQUEsWUFBQSxNQUFBLFlBQUEsR0FBQTs7QUFXbEQsWUFBSSxzQkFBVSxZQUFkLElBQUksQ0FBSixFQUFpQztBQUMvQix1QkFBVztBQUNULHNCQURTLG1CQUFBO0FBRVQsc0JBQU0sS0FBQSxVQUFBLENBQTZCLFlBRjFCLElBRUgsQ0FGRztBQUdULHdCQUhTLEVBQUE7QUFJVCxzQkFBTSxtQkFKRyxJQUlILEVBSkc7QUFBQSx5QkFBQSxPQUFBO0FBTVQscUJBQUE7QUFOUyxhQUFYO0FBREYsU0FBQSxNQVNPO0FBQUEsZ0JBQUEsb0JBQ3dCLGdCQUFBLElBQUEsRUFEeEIsV0FDd0IsQ0FEeEI7QUFBQSxnQkFBQSxPQUFBLGtCQUFBLElBQUE7QUFBQSxnQkFBQSxTQUFBLGtCQUFBLE1BQUE7QUFBQSxnQkFBQSxPQUFBLGtCQUFBLElBQUE7O0FBSUwsdUJBQVcsbUJBQUEsUUFBQSxDQUFBLElBQUEsRUFBQSxNQUFBLEVBQUEsSUFBQSxFQUErQixDQUEvQixPQUFBLEVBQVgsR0FBVyxDQUFYO0FBQ0Q7QUFFRCxnQkFBUSxVQUFSLEtBQUE7QUFDRTtBQUNBLGlCQUFBLFNBQUEsQ0FBQSxhQUFBO0FBQ0EsaUJBQUEsU0FBQSxDQUFBLGFBQUE7QUFDRSxzQkFBTSxJQUFBLHFCQUFBLENBQUEsbURBQzhDLEtBQUEsYUFBQSxDQUFBLFdBQUEsRUFFaEQsWUFIRSxJQUM4QyxDQUQ5QyxHQUFBLFFBQUEsR0FJTyxJQUFBLEtBQUEsQ0FKUCxJQUFBLEdBQUEsSUFBQSxHQUkwQixJQUFBLEtBQUEsQ0FKMUIsTUFBQSxFQUtKLFNBTEYsR0FBTSxDQUFOO0FBUUYsaUJBQUEscUJBQUEsQ0FBQSx5QkFBQTtBQUNFLG1DQUFtQixLQUFuQixlQUFBLEVBQUEsUUFBQTtBQUNBO0FBQ0YsaUJBQUEsZUFBQSxDQUFBLG1CQUFBO0FBQ0EsaUJBQUEsb0JBQUEsQ0FBQSx3QkFBQTtBQUNFLHFCQUFBLG1CQUFBLENBQUEsS0FBQTtBQUNBLHFCQUFBLG9CQUFBO0FBQ0EsbUNBQW1CLEtBQW5CLGVBQUEsRUFBQSxRQUFBO0FBQ0EsMEJBQUEsWUFBQSxDQUFBLHFCQUFBLENBQUEseUJBQUE7QUFDQTtBQUNGLGlCQUFBLDJCQUFBLENBQUEsK0JBQUE7QUFDRSxtQ0FBbUIsS0FBbkIsZUFBQSxFQUFBLFFBQUE7QUFDQSwwQkFBQSxZQUFBLENBQUEscUJBQUEsQ0FBQSx5QkFBQTtBQUNBO0FBRUY7QUFDQSxpQkFBQSxzQkFBQSxDQUFBLDBCQUFBO0FBQ0UscUJBQUEsbUJBQUEsQ0FBQSxLQUFBO0FBQ0EsZ0RBQWdDLEtBQWhDLGdCQUFBLEVBQUEsUUFBQTtBQUNBLDBCQUFBLFlBQUEsQ0FBQSx3QkFBQSxDQUFBLDRCQUFBO0FBQ0E7QUFDRixpQkFBQSw0QkFBQSxDQUFBLGdDQUFBO0FBQ0EsaUJBQUEsNEJBQUEsQ0FBQSxnQ0FBQTtBQUNBLGlCQUFBLHdCQUFBLENBQUEsNEJBQUE7QUFDRSxnREFBZ0MsS0FBaEMsZ0JBQUEsRUFBQSxRQUFBO0FBQ0E7QUFFRjtBQUNBO0FBQ0E7QUFDRSx3Q0FBWSxLQUFaLGNBQVksRUFBWixFQUFBLFFBQUE7QUExQ0o7QUE2Q0EsZUFBQSxRQUFBO0FBaktKLEtBQUE7O0FBQUEsMkJBQUEsU0FBQSxDQUFBLGdCQUFBLEdBQUEsU0FBQSxnQkFBQSxDQUFBLE9BQUEsRUFvS2dEO0FBQzVDLGdDQUF3QixLQUF4QixTQUFBLEVBQUEsT0FBQTtBQUVBLGFBQUEsU0FBQSxDQUFBLFlBQUEsQ0FBNEIsUUFBNUIsS0FBQTtBQUNBLGFBQUEsU0FBQSxDQUFBLFNBQUE7QUF4S0osS0FBQTs7QUFBQSwyQkFBQSxTQUFBLENBQUEsZ0JBQUEsR0FBQSxTQUFBLGdCQUFBLENBQUEsVUFBQSxFQTJLbUQ7QUFBQSxZQUFBLFlBQUEsS0FBQSxTQUFBOztBQUcvQyxZQUFJLFVBQUEsS0FBQSxLQUFKLFNBQUEsQ0FBQSxhQUFBLEVBQWdEO0FBQzlDLHFCQUFBLG1CQUFBLENBQXlCLEtBQUEsYUFBQSxDQUF6QixVQUF5QixDQUF6QjtBQUNBLHVCQUFBLElBQUE7QUFDRDtBQU44QyxZQUFBLFFBQUEsV0FBQSxLQUFBO0FBQUEsWUFBQSxNQUFBLFdBQUEsR0FBQTs7QUFTL0MsWUFBSSxVQUFVLG1CQUFBLGVBQUEsQ0FBQSxLQUFBLEVBQWQsR0FBYyxDQUFkO0FBRUEsZ0JBQVEsVUFBUixLQUFBO0FBQ0UsaUJBQUEscUJBQUEsQ0FBQSx5QkFBQTtBQUNFLHFCQUFBLGVBQUEsQ0FBQSxRQUFBLENBQUEsSUFBQSxDQUFBLE9BQUE7QUFDQTtBQUVGLGlCQUFBLFlBQUEsQ0FBQSxnQkFBQTtBQUNBLGlCQUFBLE1BQUEsQ0FBQSxVQUFBO0FBQ0Usd0NBQVksS0FBWixjQUFZLEVBQVosRUFBQSxPQUFBO0FBQ0E7QUFFRjtBQUNFLHNCQUFNLElBQUEscUJBQUEsQ0FBQSw2Q0FFRixVQUZFLE9BRUYsQ0FGRSxHQUFBLDZCQUFBLEdBRzJCLFFBSDNCLEtBQUEsR0FBQSxZQUFBLEdBR3FELElBQUEsS0FBQSxDQUhyRCxJQUFBLEdBQUEsR0FBQSxHQUlGLElBQUEsS0FBQSxDQUpFLE1BQUEsRUFNSixXQU5GLEdBQU0sQ0FBTjtBQVhKO0FBcUJBLGVBQUEsT0FBQTtBQTNNSixLQUFBOztBQUFBLDJCQUFBLFNBQUEsQ0FBQSxnQkFBQSxHQUFBLFNBQUEsZ0JBQUEsQ0FBQSxPQUFBLEVBOE1nRDtBQUFBLFlBQUEsTUFBQSxRQUFBLEdBQUE7O0FBRzVDLGNBQU0sSUFBQSxxQkFBQSxDQUFBLDZDQUN1QyxLQUFBLGFBQUEsQ0FBQSxPQUFBLEVBQTRCLFFBRG5FLElBQ3VDLENBRHZDLEdBQUEsUUFBQSxHQUVGLElBQUEsS0FBQSxDQUZFLElBQUEsR0FBQSxJQUFBLEdBR0MsSUFBQSxLQUFBLENBSEQsTUFBQSxFQUlKLFFBSkYsR0FBTSxDQUFOO0FBak5KLEtBQUE7O0FBQUEsMkJBQUEsU0FBQSxDQUFBLHFCQUFBLEdBQUEsU0FBQSxxQkFBQSxDQUFBLFlBQUEsRUF5TitEO0FBQUEsWUFBQSxNQUFBLGFBQUEsR0FBQTs7QUFHM0QsY0FBTSxJQUFBLHFCQUFBLENBQUEsbURBQzZDLEtBQUEsYUFBQSxDQUFBLFlBQUEsRUFFL0MsYUFIRSxJQUM2QyxDQUQ3QyxHQUFBLFFBQUEsR0FJTSxJQUFBLEtBQUEsQ0FKTixJQUFBLEdBQUEsSUFBQSxHQUl5QixJQUFBLEtBQUEsQ0FKekIsTUFBQSxFQUtKLGFBTEYsR0FBTSxDQUFOO0FBNU5KLEtBQUE7O0FBQUEsMkJBQUEsU0FBQSxDQUFBLFNBQUEsR0FBQSxTQUFBLFNBQUEsQ0FBQSxTQUFBLEVBcU9vQztBQUFBLFlBQUEsTUFBQSxVQUFBLEdBQUE7O0FBR2hDLGNBQU0sSUFBQSxxQkFBQSxDQUFBLCtDQUN5QyxLQUFBLGFBQUEsQ0FBQSxTQUFBLEVBRTNDLFVBSEUsSUFDeUMsQ0FEekMsR0FBQSxRQUFBLEdBSU0sSUFBQSxLQUFBLENBSk4sSUFBQSxHQUFBLElBQUEsR0FJeUIsSUFBQSxLQUFBLENBSnpCLE1BQUEsRUFLSixVQUxGLEdBQU0sQ0FBTjtBQXhPSixLQUFBOztBQUFBLDJCQUFBLFNBQUEsQ0FBQSxjQUFBLEdBQUEsU0FBQSxjQUFBLENBQUEsY0FBQSxFQWlQbUQ7QUFBQSxZQUFBLE1BQUEsZUFBQSxHQUFBOztBQUcvQyxjQUFNLElBQUEscUJBQUEsQ0FBQSxxREFDK0MsS0FBQSxhQUFBLENBQUEsY0FBQSxFQUVqRCxlQUhFLElBQytDLENBRC9DLEdBQUEsUUFBQSxHQUlNLElBQUEsS0FBQSxDQUpOLElBQUEsR0FBQSxJQUFBLEdBSXlCLElBQUEsS0FBQSxDQUp6QixNQUFBLEVBS0osZUFMRixHQUFNLENBQU47QUFwUEosS0FBQTs7QUFBQSwyQkFBQSxTQUFBLENBQUEsYUFBQSxHQUFBLFNBQUEsYUFBQSxDQUFBLEtBQUEsRUE2UHdDO0FBQUEsWUFBQSxvQkFDUCxnQkFBQSxJQUFBLEVBRE8sS0FDUCxDQURPO0FBQUEsWUFBQSxPQUFBLGtCQUFBLElBQUE7QUFBQSxZQUFBLFNBQUEsa0JBQUEsTUFBQTtBQUFBLFlBQUEsT0FBQSxrQkFBQSxJQUFBOztBQUVwQyxlQUFPLG1CQUFBLEtBQUEsQ0FBQSxJQUFBLEVBQUEsTUFBQSxFQUFBLElBQUEsRUFBNEIsTUFBbkMsR0FBTyxDQUFQO0FBL1BKLEtBQUE7O0FBQUEsMkJBQUEsU0FBQSxDQUFBLGNBQUEsR0FBQSxTQUFBLGNBQUEsQ0FBQSxJQUFBLEVBa1F5QztBQUFBLFlBQUEsV0FBQSxLQUFBLFFBQUE7QUFBQSxZQUFBLE1BQUEsS0FBQSxHQUFBOztBQUVyQyxZQUFBLFFBQUEsS0FBQSxDQUFBO0FBRUEsWUFBSSxTQUFBLE9BQUEsQ0FBQSxHQUFBLE1BQTBCLENBQTlCLENBQUEsRUFBa0M7QUFDaEMsZ0JBQUksU0FBQSxLQUFBLENBQUEsQ0FBQSxFQUFBLENBQUEsTUFBSixJQUFBLEVBQW1DO0FBQ2pDLHNCQUFNLElBQUEscUJBQUEsQ0FBQSw4REFDd0QsS0FEeEQsUUFBQSxHQUFBLFlBQUEsR0FFRixJQUFBLEtBQUEsQ0FGRSxJQUFBLEdBQUEsR0FBQSxFQUlKLEtBSkYsR0FBTSxDQUFOO0FBTUQ7QUFDRCxnQkFBSSxTQUFBLEtBQUEsQ0FBQSxDQUFBLEVBQUEsQ0FBQSxNQUFKLEtBQUEsRUFBb0M7QUFDbEMsc0JBQU0sSUFBQSxxQkFBQSxDQUFBLGdFQUMwRCxLQUQxRCxRQUFBLEdBQUEsWUFBQSxHQUVGLElBQUEsS0FBQSxDQUZFLElBQUEsR0FBQSxHQUFBLEVBSUosS0FKRixHQUFNLENBQU47QUFNRDtBQUNELGdCQUFJLFNBQUEsT0FBQSxDQUFBLEdBQUEsTUFBMEIsQ0FBOUIsQ0FBQSxFQUFrQztBQUNoQyxzQkFBTSxJQUFBLHFCQUFBLENBQUEsOEdBRUYsS0FGRSxRQUFBLEdBQUEsWUFBQSxHQUdTLElBQUEsS0FBQSxDQUhULElBQUEsR0FBQSxHQUFBLEVBSUosS0FKRixHQUFNLENBQU47QUFNRDtBQUNELG9CQUFRLENBQUMsS0FBQSxLQUFBLENBQUEsSUFBQSxDQUFULEdBQVMsQ0FBRCxDQUFSO0FBekJGLFNBQUEsTUEwQk8sSUFBSSxhQUFKLEdBQUEsRUFBc0I7QUFDM0IsZ0JBQUksZUFBQSxNQUFtQixJQUFBLEtBQUEsQ0FBbkIsSUFBQSxHQUFBLElBQUEsR0FBc0MsSUFBQSxLQUFBLENBQTFDLE1BQUE7QUFDQSxrQkFBTSxJQUFBLHFCQUFBLENBQUEseUZBQUEsWUFBQSxHQUFBLEdBQUEsRUFFSixLQUZGLEdBQU0sQ0FBTjtBQUZLLFNBQUEsTUFNQTtBQUNMLG9CQUFRLEtBQVIsS0FBQTtBQUNEO0FBRUQsWUFBSSxXQUFKLEtBQUE7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQUksU0FBQSxLQUFBLENBQUosZUFBSSxDQUFKLEVBQXFDO0FBQ25DLHVCQUFBLElBQUE7QUFDRDtBQUVELGVBQU87QUFDTCxrQkFESyxnQkFBQTtBQUVMLHNCQUFVLEtBRkwsUUFBQTtBQUdMLGtCQUhLLFFBQUE7QUFBQSxtQkFBQSxLQUFBO0FBS0wsa0JBQU0sS0FMRCxJQUFBO0FBTUwsaUJBQUssS0FBSztBQU5MLFNBQVA7QUExVEosS0FBQTs7QUFBQSwyQkFBQSxTQUFBLENBQUEsSUFBQSxHQUFBLFNBQUEsSUFBQSxDQUFBLElBQUEsRUFvVXFCO0FBQ2pCLFlBQUksUUFBSixFQUFBO0FBRUEsYUFBSyxJQUFJLElBQVQsQ0FBQSxFQUFnQixJQUFJLEtBQUEsS0FBQSxDQUFwQixNQUFBLEVBQUEsR0FBQSxFQUE0QztBQUMxQyxnQkFBSSxPQUFPLEtBQUEsS0FBQSxDQUFYLENBQVcsQ0FBWDtBQUNBLGtCQUFBLElBQUEsQ0FBVyxtQkFBQSxJQUFBLENBQU8sS0FBUCxHQUFBLEVBQWlCLEtBQUEsVUFBQSxDQUFnQixLQUFqQyxLQUFpQixDQUFqQixFQUE4QyxLQUF6RCxHQUFXLENBQVg7QUFDRDtBQUVELGVBQU8sbUJBQUEsSUFBQSxDQUFBLEtBQUEsRUFBYyxLQUFyQixHQUFPLENBQVA7QUE1VUosS0FBQTs7QUFBQSwyQkFBQSxTQUFBLENBQUEsYUFBQSxHQUFBLFNBQUEsYUFBQSxDQUFBLE1BQUEsRUErVXlDO0FBQ3JDLGVBQU8sbUJBQUEsT0FBQSxDQUFBLGVBQUEsRUFBMkIsT0FBM0IsS0FBQSxFQUF5QyxPQUFoRCxHQUFPLENBQVA7QUFoVkosS0FBQTs7QUFBQSwyQkFBQSxTQUFBLENBQUEsY0FBQSxHQUFBLFNBQUEsY0FBQSxDQUFBLE9BQUEsRUFtVjRDO0FBQ3hDLGVBQU8sbUJBQUEsT0FBQSxDQUFBLGdCQUFBLEVBQTRCLFFBQTVCLEtBQUEsRUFBMkMsUUFBbEQsR0FBTyxDQUFQO0FBcFZKLEtBQUE7O0FBQUEsMkJBQUEsU0FBQSxDQUFBLGFBQUEsR0FBQSxTQUFBLGFBQUEsQ0FBQSxNQUFBLEVBdVZ5QztBQUNyQyxlQUFPLG1CQUFBLE9BQUEsQ0FBQSxlQUFBLEVBQTJCLE9BQTNCLEtBQUEsRUFBeUMsT0FBaEQsR0FBTyxDQUFQO0FBeFZKLEtBQUE7O0FBQUEsMkJBQUEsU0FBQSxDQUFBLGdCQUFBLEdBQUEsU0FBQSxnQkFBQSxDQUFBLEtBQUEsRUEyVjhDO0FBQzFDLGVBQU8sbUJBQUEsT0FBQSxDQUFBLGtCQUFBLEVBQUEsU0FBQSxFQUF5QyxNQUFoRCxHQUFPLENBQVA7QUE1VkosS0FBQTs7QUFBQSwyQkFBQSxTQUFBLENBQUEsV0FBQSxHQUFBLFNBQUEsV0FBQSxDQUFBLEdBQUEsRUErVmtDO0FBQzlCLGVBQU8sbUJBQUEsT0FBQSxDQUFBLGFBQUEsRUFBQSxJQUFBLEVBQStCLElBQXRDLEdBQU8sQ0FBUDtBQWhXSixLQUFBOztBQUFBLGlCQUFBLHNCQUFBLEVBQUEsQ0FBQTtBQUFBLGFBQUEsWUFBQTtBQUFBLGFBQUEsU0FBQSxHQUFBLEdBV3dCO0FBQ3BCLG1CQUFPLEtBQUEsWUFBQSxDQUFBLE1BQUEsS0FBUCxDQUFBO0FBQ0Q7QUFiSCxLQUFBLENBQUE7O0FBQUEsV0FBQSxzQkFBQTtBQUFBLENBQUEsQ0FBQSxjQUFBLENBQUE7QUFvV0EsU0FBQSw2QkFBQSxDQUFBLFFBQUEsRUFBQSxLQUFBLEVBQXNFO0FBQ3BFLFFBQUksVUFBSixFQUFBLEVBQWtCO0FBQ2hCO0FBQ0E7QUFDQSxlQUFPO0FBQ0wsbUJBQU8sU0FBQSxLQUFBLENBQUEsSUFBQSxFQUFBLE1BQUEsR0FERixDQUFBO0FBRUwscUJBQVM7QUFGSixTQUFQO0FBSUQ7QUFFRDtBQUNBO0FBQ0EsUUFBSSxhQUFhLFNBQUEsS0FBQSxDQUFBLEtBQUEsRUFBakIsQ0FBaUIsQ0FBakI7QUFDQSxRQUFJLFFBQVEsV0FBQSxLQUFBLENBQVosSUFBWSxDQUFaO0FBQ0EsUUFBSSxZQUFZLE1BQUEsTUFBQSxHQUFoQixDQUFBO0FBRUEsV0FBTztBQUNMLGVBREssU0FBQTtBQUVMLGlCQUFTLE1BQUEsU0FBQSxFQUFpQjtBQUZyQixLQUFQO0FBSUQ7QUFFRCxTQUFBLHVCQUFBLENBQUEsU0FBQSxFQUFBLE9BQUEsRUFBOEY7QUFDNUYsUUFBSSxPQUFPLFFBQUEsR0FBQSxDQUFBLEtBQUEsQ0FBWCxJQUFBO0FBQ0EsUUFBSSxTQUFTLFFBQUEsR0FBQSxDQUFBLEtBQUEsQ0FBYixNQUFBO0FBRUEsUUFBSSxVQUFVLDhCQUNaLFFBRFksUUFBQSxFQUVaLFFBRkYsS0FBYyxDQUFkO0FBS0EsV0FBTyxPQUFPLFFBQWQsS0FBQTtBQUNBLFFBQUksUUFBSixLQUFBLEVBQW1CO0FBQ2pCLGlCQUFTLFFBQVQsT0FBQTtBQURGLEtBQUEsTUFFTztBQUNMLGlCQUFTLFNBQVMsUUFBbEIsT0FBQTtBQUNEO0FBRUQsY0FBQSxJQUFBLEdBQUEsSUFBQTtBQUNBLGNBQUEsTUFBQSxHQUFBLE1BQUE7QUFDRDtBQUVELFNBQUEsZUFBQSxDQUFBLFFBQUEsRUFBQSxJQUFBLEVBTUc7QUFFRCxRQUFJLE9BQU8sU0FBQSxjQUFBLENBQXdCLEtBQW5DLElBQVcsQ0FBWDtBQUVBLFFBQUksU0FBUyxLQUFBLE1BQUEsR0FBYyxLQUFBLE1BQUEsQ0FBQSxHQUFBLENBQWdCLFVBQUEsQ0FBQSxFQUFBO0FBQUEsZUFBSyxTQUFBLFVBQUEsQ0FBbkMsQ0FBbUMsQ0FBTDtBQUE5QixLQUFjLENBQWQsR0FBYixFQUFBO0FBQ0EsUUFBSSxPQUFPLEtBQUEsSUFBQSxHQUFZLFNBQUEsSUFBQSxDQUFjLEtBQTFCLElBQVksQ0FBWixHQUF1QyxtQkFBbEQsSUFBa0QsRUFBbEQ7QUFFQSxXQUFPLEVBQUEsTUFBQSxJQUFBLEVBQUEsUUFBQSxNQUFBLEVBQVAsTUFBQSxJQUFPLEVBQVA7QUFDRDtBQUVELFNBQUEsa0JBQUEsQ0FBQSxPQUFBLEVBQUEsUUFBQSxFQUFxRjtBQUFBLFFBQUEsT0FBQSxTQUFBLElBQUE7QUFBQSxRQUFBLFNBQUEsU0FBQSxNQUFBO0FBQUEsUUFBQSxPQUFBLFNBQUEsSUFBQTtBQUFBLFFBQUEsTUFBQSxTQUFBLEdBQUE7O0FBR25GLFFBQUksc0JBQUosSUFBSSxDQUFKLEVBQXFCO0FBQ25CLFlBQUksWUFBQSxPQUFnQix5QkFBcEIsSUFBb0IsQ0FBaEIsR0FBSixJQUFBO0FBQ0EsWUFBSSxNQUFBLE1BQVUsUUFBVixJQUFBLEdBQUEsT0FBQSxHQUFKLFNBQUksR0FBSixNQUFBO0FBRUEsY0FBTSxJQUFBLHFCQUFBLENBQUEsUUFBQSxHQUFBLEdBQUEsSUFBQSxHQUFBLFNBQUEsR0FBQSw2QkFBQSxHQUNnRCxLQURoRCxRQUFBLEdBQUEsWUFBQSxJQUMwRSxPQUM1RSxJQUFBLEtBQUEsQ0FGRSxJQUFBLElBQUEsR0FBQSxFQUdKLFNBSEYsR0FBTSxDQUFOO0FBS0Q7QUFFRCxRQUFJLFdBQVcsbUJBQUEsZUFBQSxDQUFBLElBQUEsRUFBQSxNQUFBLEVBQUEsSUFBQSxFQUFmLEdBQWUsQ0FBZjtBQUNBLFlBQUEsU0FBQSxDQUFBLElBQUEsQ0FBQSxRQUFBO0FBQ0Q7QUFFRCxTQUFBLGdCQUFBLENBQUEsTUFBQSxFQUFBLElBQUEsRUFBQSxHQUFBLEVBQWlGO0FBQy9FLFFBQUksa0JBQUosS0FBQTtBQUNBLFNBQUEsS0FBQSxDQUFBLE9BQUEsQ0FBbUIsVUFBQSxJQUFBLEVBQU87QUFDeEIsWUFBSSxLQUFBLEdBQUEsS0FBSixNQUFBLEVBQXlCO0FBQ3ZCLGtCQUFNLElBQUEscUJBQUEsQ0FBQSxvQ0FBQSxFQUFOLEdBQU0sQ0FBTjtBQUNEO0FBRUQsWUFBSSxLQUFBLEdBQUEsS0FBSixjQUFBLEVBQWlDO0FBQy9CLDhCQUFBLElBQUE7QUFDRDtBQVBILEtBQUE7QUFVQSxRQUFJLE9BQU8sbUJBQUEsT0FBQSxDQUFBLGVBQUEsRUFBWCxNQUFXLENBQVg7QUFDQSxRQUFJLFdBQVcsbUJBQUEsSUFBQSxDQUFBLE1BQUEsRUFBZixJQUFlLENBQWY7QUFDQSxTQUFBLEtBQUEsQ0FBQSxPQUFBLENBQUEsUUFBQTtBQUVBLFFBQUksQ0FBSixlQUFBLEVBQXNCO0FBQ3BCLFlBQUksbUJBQW1CLG1CQUFBLE9BQUEsQ0FBQSxrQkFBQSxFQUF2QixTQUF1QixDQUF2QjtBQUNBLFlBQUksZ0JBQWdCLG1CQUFBLElBQUEsQ0FBQSxjQUFBLEVBQXBCLGdCQUFvQixDQUFwQjtBQUNBLGFBQUEsS0FBQSxDQUFBLElBQUEsQ0FBQSxhQUFBO0FBQ0Q7QUFFRCxXQUFBLElBQUE7QUFDRDtBQUVELFNBQUEsK0JBQUEsQ0FBQSxTQUFBLEVBQUEsSUFBQSxFQUEwRjtBQUN4RixjQUFBLFNBQUEsR0FBQSxJQUFBO0FBQ0EsY0FBQSxLQUFBLENBQUEsSUFBQSxDQUFBLElBQUE7QUFDRCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBiIGZyb20gJy4uL2J1aWxkZXJzJztcbmltcG9ydCB7IGFwcGVuZENoaWxkLCBpc0xpdGVyYWwsIHByaW50TGl0ZXJhbCB9IGZyb20gJy4uL3V0aWxzJztcbmltcG9ydCAqIGFzIEFTVCBmcm9tICcuLi90eXBlcy9ub2Rlcyc7XG5pbXBvcnQgKiBhcyBIQlMgZnJvbSAnLi4vdHlwZXMvaGFuZGxlYmFycy1hc3QnO1xuaW1wb3J0IHsgUGFyc2VyLCBUYWcsIEF0dHJpYnV0ZSB9IGZyb20gJy4uL3BhcnNlcic7XG5pbXBvcnQgU3ludGF4RXJyb3IgZnJvbSAnLi4vZXJyb3JzL3N5bnRheC1lcnJvcic7XG5pbXBvcnQgeyBPcHRpb24gfSBmcm9tICdAZ2xpbW1lci91dGlsJztcbmltcG9ydCB7IFJlY2FzdCB9IGZyb20gJ0BnbGltbWVyL2ludGVyZmFjZXMnO1xuaW1wb3J0IHsgVG9rZW5pemVyU3RhdGUgfSBmcm9tICdzaW1wbGUtaHRtbC10b2tlbml6ZXInO1xuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgSGFuZGxlYmFyc05vZGVWaXNpdG9ycyBleHRlbmRzIFBhcnNlciB7XG4gIGFic3RyYWN0IGFwcGVuZFRvQ29tbWVudERhdGEoczogc3RyaW5nKTogdm9pZDtcbiAgYWJzdHJhY3QgYmVnaW5BdHRyaWJ1dGVWYWx1ZShxdW90ZWQ6IGJvb2xlYW4pOiB2b2lkO1xuICBhYnN0cmFjdCBmaW5pc2hBdHRyaWJ1dGVWYWx1ZSgpOiB2b2lkO1xuXG4gIGN1cnNvckNvdW50ID0gMDtcblxuICBjdXJzb3IoKSB7XG4gICAgcmV0dXJuIGAlY3Vyc29yOiR7dGhpcy5jdXJzb3JDb3VudCsrfSVgO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXQgaXNUb3BMZXZlbCgpIHtcbiAgICByZXR1cm4gdGhpcy5lbGVtZW50U3RhY2subGVuZ3RoID09PSAwO1xuICB9XG5cbiAgUHJvZ3JhbShwcm9ncmFtOiBIQlMuUHJvZ3JhbSk6IEFTVC5CbG9jaztcbiAgUHJvZ3JhbShwcm9ncmFtOiBIQlMuUHJvZ3JhbSk6IEFTVC5UZW1wbGF0ZTtcbiAgUHJvZ3JhbShwcm9ncmFtOiBIQlMuUHJvZ3JhbSk6IEFTVC5UZW1wbGF0ZSB8IEFTVC5CbG9jaztcbiAgUHJvZ3JhbShwcm9ncmFtOiBIQlMuUHJvZ3JhbSk6IEFTVC5CbG9jayB8IEFTVC5UZW1wbGF0ZSB7XG4gICAgbGV0IGJvZHk6IEFTVC5TdGF0ZW1lbnRbXSA9IFtdO1xuICAgIHRoaXMuY3Vyc29yQ291bnQgPSAwO1xuXG4gICAgbGV0IG5vZGU7XG5cbiAgICBpZiAodGhpcy5pc1RvcExldmVsKSB7XG4gICAgICBub2RlID0gYi50ZW1wbGF0ZShib2R5LCBwcm9ncmFtLmJsb2NrUGFyYW1zLCBwcm9ncmFtLmxvYyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG5vZGUgPSBiLmJsb2NrSXRzZWxmKGJvZHksIHByb2dyYW0uYmxvY2tQYXJhbXMsIHByb2dyYW0uY2hhaW5lZCwgcHJvZ3JhbS5sb2MpO1xuICAgIH1cblxuICAgIGxldCBpLFxuICAgICAgbCA9IHByb2dyYW0uYm9keS5sZW5ndGg7XG5cbiAgICB0aGlzLmVsZW1lbnRTdGFjay5wdXNoKG5vZGUpO1xuXG4gICAgaWYgKGwgPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzLmVsZW1lbnRTdGFjay5wb3AoKSBhcyBBU1QuQmxvY2sgfCBBU1QuVGVtcGxhdGU7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgdGhpcy5hY2NlcHROb2RlKHByb2dyYW0uYm9keVtpXSk7XG4gICAgfVxuXG4gICAgLy8gRW5zdXJlIHRoYXQgdGhhdCB0aGUgZWxlbWVudCBzdGFjayBpcyBiYWxhbmNlZCBwcm9wZXJseS5cbiAgICBsZXQgcG9wcGVkTm9kZSA9IHRoaXMuZWxlbWVudFN0YWNrLnBvcCgpO1xuICAgIGlmIChwb3BwZWROb2RlICE9PSBub2RlKSB7XG4gICAgICBsZXQgZWxlbWVudE5vZGUgPSBwb3BwZWROb2RlIGFzIEFTVC5FbGVtZW50Tm9kZTtcblxuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFxuICAgICAgICAnVW5jbG9zZWQgZWxlbWVudCBgJyArIGVsZW1lbnROb2RlLnRhZyArICdgIChvbiBsaW5lICcgKyBlbGVtZW50Tm9kZS5sb2MhLnN0YXJ0LmxpbmUgKyAnKS4nLFxuICAgICAgICBlbGVtZW50Tm9kZS5sb2NcbiAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH1cblxuICBCbG9ja1N0YXRlbWVudChibG9jazogSEJTLkJsb2NrU3RhdGVtZW50KTogQVNULkJsb2NrU3RhdGVtZW50IHwgdm9pZCB7XG4gICAgaWYgKHRoaXMudG9rZW5pemVyWydzdGF0ZSddID09PSAnY29tbWVudCcpIHtcbiAgICAgIHRoaXMuYXBwZW5kVG9Db21tZW50RGF0YSh0aGlzLnNvdXJjZUZvck5vZGUoYmxvY2spKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICB0aGlzLnRva2VuaXplclsnc3RhdGUnXSAhPT0gJ2NvbW1lbnQnICYmXG4gICAgICB0aGlzLnRva2VuaXplclsnc3RhdGUnXSAhPT0gJ2RhdGEnICYmXG4gICAgICB0aGlzLnRva2VuaXplclsnc3RhdGUnXSAhPT0gJ2JlZm9yZURhdGEnXG4gICAgKSB7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXG4gICAgICAgICdBIGJsb2NrIG1heSBvbmx5IGJlIHVzZWQgaW5zaWRlIGFuIEhUTUwgZWxlbWVudCBvciBhbm90aGVyIGJsb2NrLicsXG4gICAgICAgIGJsb2NrLmxvY1xuICAgICAgKTtcbiAgICB9XG5cbiAgICBsZXQgeyBwYXRoLCBwYXJhbXMsIGhhc2ggfSA9IGFjY2VwdENhbGxOb2Rlcyh0aGlzLCBibG9jayk7XG4gICAgbGV0IHByb2dyYW0gPSB0aGlzLlByb2dyYW0oYmxvY2sucHJvZ3JhbSk7XG4gICAgbGV0IGludmVyc2UgPSBibG9jay5pbnZlcnNlID8gdGhpcy5Qcm9ncmFtKGJsb2NrLmludmVyc2UpIDogbnVsbDtcblxuICAgIGlmIChwYXRoLm9yaWdpbmFsID09PSAnaW4tZWxlbWVudCcpIHtcbiAgICAgIGhhc2ggPSBhZGRJbkVsZW1lbnRIYXNoKHRoaXMuY3Vyc29yKCksIGhhc2gsIGJsb2NrLmxvYyk7XG4gICAgfVxuXG4gICAgbGV0IG5vZGUgPSBiLmJsb2NrKHBhdGgsIHBhcmFtcywgaGFzaCwgcHJvZ3JhbSwgaW52ZXJzZSwgYmxvY2subG9jKTtcblxuICAgIGxldCBwYXJlbnRQcm9ncmFtID0gdGhpcy5jdXJyZW50RWxlbWVudCgpO1xuXG4gICAgYXBwZW5kQ2hpbGQocGFyZW50UHJvZ3JhbSwgbm9kZSk7XG4gIH1cblxuICBNdXN0YWNoZVN0YXRlbWVudChyYXdNdXN0YWNoZTogSEJTLk11c3RhY2hlU3RhdGVtZW50KTogQVNULk11c3RhY2hlU3RhdGVtZW50IHwgdm9pZCB7XG4gICAgbGV0IHsgdG9rZW5pemVyIH0gPSB0aGlzO1xuXG4gICAgaWYgKHRva2VuaXplci5zdGF0ZSA9PT0gJ2NvbW1lbnQnKSB7XG4gICAgICB0aGlzLmFwcGVuZFRvQ29tbWVudERhdGEodGhpcy5zb3VyY2VGb3JOb2RlKHJhd011c3RhY2hlKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgbGV0IG11c3RhY2hlOiBBU1QuTXVzdGFjaGVTdGF0ZW1lbnQ7XG4gICAgbGV0IHsgZXNjYXBlZCwgbG9jIH0gPSByYXdNdXN0YWNoZTtcblxuICAgIGlmIChpc0xpdGVyYWwocmF3TXVzdGFjaGUucGF0aCkpIHtcbiAgICAgIG11c3RhY2hlID0ge1xuICAgICAgICB0eXBlOiAnTXVzdGFjaGVTdGF0ZW1lbnQnLFxuICAgICAgICBwYXRoOiB0aGlzLmFjY2VwdE5vZGU8QVNULkxpdGVyYWw+KHJhd011c3RhY2hlLnBhdGgpLFxuICAgICAgICBwYXJhbXM6IFtdLFxuICAgICAgICBoYXNoOiBiLmhhc2goKSxcbiAgICAgICAgZXNjYXBlZCxcbiAgICAgICAgbG9jLFxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IHsgcGF0aCwgcGFyYW1zLCBoYXNoIH0gPSBhY2NlcHRDYWxsTm9kZXModGhpcywgcmF3TXVzdGFjaGUgYXMgSEJTLk11c3RhY2hlU3RhdGVtZW50ICYge1xuICAgICAgICBwYXRoOiBIQlMuUGF0aEV4cHJlc3Npb247XG4gICAgICB9KTtcbiAgICAgIG11c3RhY2hlID0gYi5tdXN0YWNoZShwYXRoLCBwYXJhbXMsIGhhc2gsICFlc2NhcGVkLCBsb2MpO1xuICAgIH1cblxuICAgIHN3aXRjaCAodG9rZW5pemVyLnN0YXRlKSB7XG4gICAgICAvLyBUYWcgaGVscGVyc1xuICAgICAgY2FzZSBUb2tlbml6ZXJTdGF0ZS50YWdPcGVuOlxuICAgICAgY2FzZSBUb2tlbml6ZXJTdGF0ZS50YWdOYW1lOlxuICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXG4gICAgICAgICAgYENhbm5vdCB1c2UgbXVzdGFjaGVzIGluIGFuIGVsZW1lbnRzIHRhZ25hbWU6IFxcYCR7dGhpcy5zb3VyY2VGb3JOb2RlKFxuICAgICAgICAgICAgcmF3TXVzdGFjaGUsXG4gICAgICAgICAgICByYXdNdXN0YWNoZS5wYXRoXG4gICAgICAgICAgKX1cXGAgYXQgTCR7bG9jLnN0YXJ0LmxpbmV9OkMke2xvYy5zdGFydC5jb2x1bW59YCxcbiAgICAgICAgICBtdXN0YWNoZS5sb2NcbiAgICAgICAgKTtcblxuICAgICAgY2FzZSBUb2tlbml6ZXJTdGF0ZS5iZWZvcmVBdHRyaWJ1dGVOYW1lOlxuICAgICAgICBhZGRFbGVtZW50TW9kaWZpZXIodGhpcy5jdXJyZW50U3RhcnRUYWcsIG11c3RhY2hlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRva2VuaXplclN0YXRlLmF0dHJpYnV0ZU5hbWU6XG4gICAgICBjYXNlIFRva2VuaXplclN0YXRlLmFmdGVyQXR0cmlidXRlTmFtZTpcbiAgICAgICAgdGhpcy5iZWdpbkF0dHJpYnV0ZVZhbHVlKGZhbHNlKTtcbiAgICAgICAgdGhpcy5maW5pc2hBdHRyaWJ1dGVWYWx1ZSgpO1xuICAgICAgICBhZGRFbGVtZW50TW9kaWZpZXIodGhpcy5jdXJyZW50U3RhcnRUYWcsIG11c3RhY2hlKTtcbiAgICAgICAgdG9rZW5pemVyLnRyYW5zaXRpb25UbyhUb2tlbml6ZXJTdGF0ZS5iZWZvcmVBdHRyaWJ1dGVOYW1lKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFRva2VuaXplclN0YXRlLmFmdGVyQXR0cmlidXRlVmFsdWVRdW90ZWQ6XG4gICAgICAgIGFkZEVsZW1lbnRNb2RpZmllcih0aGlzLmN1cnJlbnRTdGFydFRhZywgbXVzdGFjaGUpO1xuICAgICAgICB0b2tlbml6ZXIudHJhbnNpdGlvblRvKFRva2VuaXplclN0YXRlLmJlZm9yZUF0dHJpYnV0ZU5hbWUpO1xuICAgICAgICBicmVhaztcblxuICAgICAgLy8gQXR0cmlidXRlIHZhbHVlc1xuICAgICAgY2FzZSBUb2tlbml6ZXJTdGF0ZS5iZWZvcmVBdHRyaWJ1dGVWYWx1ZTpcbiAgICAgICAgdGhpcy5iZWdpbkF0dHJpYnV0ZVZhbHVlKGZhbHNlKTtcbiAgICAgICAgYXBwZW5kRHluYW1pY0F0dHJpYnV0ZVZhbHVlUGFydCh0aGlzLmN1cnJlbnRBdHRyaWJ1dGUhLCBtdXN0YWNoZSk7XG4gICAgICAgIHRva2VuaXplci50cmFuc2l0aW9uVG8oVG9rZW5pemVyU3RhdGUuYXR0cmlidXRlVmFsdWVVbnF1b3RlZCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBUb2tlbml6ZXJTdGF0ZS5hdHRyaWJ1dGVWYWx1ZURvdWJsZVF1b3RlZDpcbiAgICAgIGNhc2UgVG9rZW5pemVyU3RhdGUuYXR0cmlidXRlVmFsdWVTaW5nbGVRdW90ZWQ6XG4gICAgICBjYXNlIFRva2VuaXplclN0YXRlLmF0dHJpYnV0ZVZhbHVlVW5xdW90ZWQ6XG4gICAgICAgIGFwcGVuZER5bmFtaWNBdHRyaWJ1dGVWYWx1ZVBhcnQodGhpcy5jdXJyZW50QXR0cmlidXRlISwgbXVzdGFjaGUpO1xuICAgICAgICBicmVhaztcblxuICAgICAgLy8gVE9ETzogT25seSBhcHBlbmQgY2hpbGQgd2hlbiB0aGUgdG9rZW5pemVyIHN0YXRlIG1ha2VzXG4gICAgICAvLyBzZW5zZSB0byBkbyBzbywgb3RoZXJ3aXNlIHRocm93IGFuIGVycm9yLlxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgYXBwZW5kQ2hpbGQodGhpcy5jdXJyZW50RWxlbWVudCgpLCBtdXN0YWNoZSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG11c3RhY2hlO1xuICB9XG5cbiAgQ29udGVudFN0YXRlbWVudChjb250ZW50OiBIQlMuQ29udGVudFN0YXRlbWVudCk6IHZvaWQge1xuICAgIHVwZGF0ZVRva2VuaXplckxvY2F0aW9uKHRoaXMudG9rZW5pemVyLCBjb250ZW50KTtcblxuICAgIHRoaXMudG9rZW5pemVyLnRva2VuaXplUGFydChjb250ZW50LnZhbHVlKTtcbiAgICB0aGlzLnRva2VuaXplci5mbHVzaERhdGEoKTtcbiAgfVxuXG4gIENvbW1lbnRTdGF0ZW1lbnQocmF3Q29tbWVudDogSEJTLkNvbW1lbnRTdGF0ZW1lbnQpOiBPcHRpb248QVNULk11c3RhY2hlQ29tbWVudFN0YXRlbWVudD4ge1xuICAgIGxldCB7IHRva2VuaXplciB9ID0gdGhpcztcblxuICAgIGlmICh0b2tlbml6ZXIuc3RhdGUgPT09IFRva2VuaXplclN0YXRlLmNvbW1lbnQpIHtcbiAgICAgIHRoaXMuYXBwZW5kVG9Db21tZW50RGF0YSh0aGlzLnNvdXJjZUZvck5vZGUocmF3Q29tbWVudCkpO1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgbGV0IHsgdmFsdWUsIGxvYyB9ID0gcmF3Q29tbWVudDtcbiAgICBsZXQgY29tbWVudCA9IGIubXVzdGFjaGVDb21tZW50KHZhbHVlLCBsb2MpO1xuXG4gICAgc3dpdGNoICh0b2tlbml6ZXIuc3RhdGUpIHtcbiAgICAgIGNhc2UgVG9rZW5pemVyU3RhdGUuYmVmb3JlQXR0cmlidXRlTmFtZTpcbiAgICAgICAgdGhpcy5jdXJyZW50U3RhcnRUYWcuY29tbWVudHMucHVzaChjb21tZW50KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgVG9rZW5pemVyU3RhdGUuYmVmb3JlRGF0YTpcbiAgICAgIGNhc2UgVG9rZW5pemVyU3RhdGUuZGF0YTpcbiAgICAgICAgYXBwZW5kQ2hpbGQodGhpcy5jdXJyZW50RWxlbWVudCgpLCBjb21tZW50KTtcbiAgICAgICAgYnJlYWs7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcbiAgICAgICAgICBgVXNpbmcgYSBIYW5kbGViYXJzIGNvbW1lbnQgd2hlbiBpbiB0aGUgXFxgJHtcbiAgICAgICAgICAgIHRva2VuaXplclsnc3RhdGUnXVxuICAgICAgICAgIH1cXGAgc3RhdGUgaXMgbm90IHN1cHBvcnRlZDogXCIke2NvbW1lbnQudmFsdWV9XCIgb24gbGluZSAke2xvYy5zdGFydC5saW5lfToke1xuICAgICAgICAgICAgbG9jLnN0YXJ0LmNvbHVtblxuICAgICAgICAgIH1gLFxuICAgICAgICAgIHJhd0NvbW1lbnQubG9jXG4gICAgICAgICk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGNvbW1lbnQ7XG4gIH1cblxuICBQYXJ0aWFsU3RhdGVtZW50KHBhcnRpYWw6IEhCUy5QYXJ0aWFsU3RhdGVtZW50KTogbmV2ZXIge1xuICAgIGxldCB7IGxvYyB9ID0gcGFydGlhbDtcblxuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcbiAgICAgIGBIYW5kbGViYXJzIHBhcnRpYWxzIGFyZSBub3Qgc3VwcG9ydGVkOiBcIiR7dGhpcy5zb3VyY2VGb3JOb2RlKHBhcnRpYWwsIHBhcnRpYWwubmFtZSl9XCIgYXQgTCR7XG4gICAgICAgIGxvYy5zdGFydC5saW5lXG4gICAgICB9OkMke2xvYy5zdGFydC5jb2x1bW59YCxcbiAgICAgIHBhcnRpYWwubG9jXG4gICAgKTtcbiAgfVxuXG4gIFBhcnRpYWxCbG9ja1N0YXRlbWVudChwYXJ0aWFsQmxvY2s6IEhCUy5QYXJ0aWFsQmxvY2tTdGF0ZW1lbnQpOiBuZXZlciB7XG4gICAgbGV0IHsgbG9jIH0gPSBwYXJ0aWFsQmxvY2s7XG5cbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXG4gICAgICBgSGFuZGxlYmFycyBwYXJ0aWFsIGJsb2NrcyBhcmUgbm90IHN1cHBvcnRlZDogXCIke3RoaXMuc291cmNlRm9yTm9kZShcbiAgICAgICAgcGFydGlhbEJsb2NrLFxuICAgICAgICBwYXJ0aWFsQmxvY2submFtZVxuICAgICAgKX1cIiBhdCBMJHtsb2Muc3RhcnQubGluZX06QyR7bG9jLnN0YXJ0LmNvbHVtbn1gLFxuICAgICAgcGFydGlhbEJsb2NrLmxvY1xuICAgICk7XG4gIH1cblxuICBEZWNvcmF0b3IoZGVjb3JhdG9yOiBIQlMuRGVjb3JhdG9yKTogbmV2ZXIge1xuICAgIGxldCB7IGxvYyB9ID0gZGVjb3JhdG9yO1xuXG4gICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFxuICAgICAgYEhhbmRsZWJhcnMgZGVjb3JhdG9ycyBhcmUgbm90IHN1cHBvcnRlZDogXCIke3RoaXMuc291cmNlRm9yTm9kZShcbiAgICAgICAgZGVjb3JhdG9yLFxuICAgICAgICBkZWNvcmF0b3IucGF0aFxuICAgICAgKX1cIiBhdCBMJHtsb2Muc3RhcnQubGluZX06QyR7bG9jLnN0YXJ0LmNvbHVtbn1gLFxuICAgICAgZGVjb3JhdG9yLmxvY1xuICAgICk7XG4gIH1cblxuICBEZWNvcmF0b3JCbG9jayhkZWNvcmF0b3JCbG9jazogSEJTLkRlY29yYXRvckJsb2NrKTogbmV2ZXIge1xuICAgIGxldCB7IGxvYyB9ID0gZGVjb3JhdG9yQmxvY2s7XG5cbiAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXG4gICAgICBgSGFuZGxlYmFycyBkZWNvcmF0b3IgYmxvY2tzIGFyZSBub3Qgc3VwcG9ydGVkOiBcIiR7dGhpcy5zb3VyY2VGb3JOb2RlKFxuICAgICAgICBkZWNvcmF0b3JCbG9jayxcbiAgICAgICAgZGVjb3JhdG9yQmxvY2sucGF0aFxuICAgICAgKX1cIiBhdCBMJHtsb2Muc3RhcnQubGluZX06QyR7bG9jLnN0YXJ0LmNvbHVtbn1gLFxuICAgICAgZGVjb3JhdG9yQmxvY2subG9jXG4gICAgKTtcbiAgfVxuXG4gIFN1YkV4cHJlc3Npb24oc2V4cHI6IEhCUy5TdWJFeHByZXNzaW9uKTogQVNULlN1YkV4cHJlc3Npb24ge1xuICAgIGxldCB7IHBhdGgsIHBhcmFtcywgaGFzaCB9ID0gYWNjZXB0Q2FsbE5vZGVzKHRoaXMsIHNleHByKTtcbiAgICByZXR1cm4gYi5zZXhwcihwYXRoLCBwYXJhbXMsIGhhc2gsIHNleHByLmxvYyk7XG4gIH1cblxuICBQYXRoRXhwcmVzc2lvbihwYXRoOiBIQlMuUGF0aEV4cHJlc3Npb24pOiBBU1QuUGF0aEV4cHJlc3Npb24ge1xuICAgIGxldCB7IG9yaWdpbmFsLCBsb2MgfSA9IHBhdGg7XG4gICAgbGV0IHBhcnRzOiBzdHJpbmdbXTtcblxuICAgIGlmIChvcmlnaW5hbC5pbmRleE9mKCcvJykgIT09IC0xKSB7XG4gICAgICBpZiAob3JpZ2luYWwuc2xpY2UoMCwgMikgPT09ICcuLycpIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFxuICAgICAgICAgIGBVc2luZyBcIi4vXCIgaXMgbm90IHN1cHBvcnRlZCBpbiBHbGltbWVyIGFuZCB1bm5lY2Vzc2FyeTogXCIke3BhdGgub3JpZ2luYWx9XCIgb24gbGluZSAke1xuICAgICAgICAgICAgbG9jLnN0YXJ0LmxpbmVcbiAgICAgICAgICB9LmAsXG4gICAgICAgICAgcGF0aC5sb2NcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChvcmlnaW5hbC5zbGljZSgwLCAzKSA9PT0gJy4uLycpIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFxuICAgICAgICAgIGBDaGFuZ2luZyBjb250ZXh0IHVzaW5nIFwiLi4vXCIgaXMgbm90IHN1cHBvcnRlZCBpbiBHbGltbWVyOiBcIiR7cGF0aC5vcmlnaW5hbH1cIiBvbiBsaW5lICR7XG4gICAgICAgICAgICBsb2Muc3RhcnQubGluZVxuICAgICAgICAgIH0uYCxcbiAgICAgICAgICBwYXRoLmxvY1xuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKG9yaWdpbmFsLmluZGV4T2YoJy4nKSAhPT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKFxuICAgICAgICAgIGBNaXhpbmcgJy4nIGFuZCAnLycgaW4gcGF0aHMgaXMgbm90IHN1cHBvcnRlZCBpbiBHbGltbWVyOyB1c2Ugb25seSAnLicgdG8gc2VwYXJhdGUgcHJvcGVydHkgcGF0aHM6IFwiJHtcbiAgICAgICAgICAgIHBhdGgub3JpZ2luYWxcbiAgICAgICAgICB9XCIgb24gbGluZSAke2xvYy5zdGFydC5saW5lfS5gLFxuICAgICAgICAgIHBhdGgubG9jXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBwYXJ0cyA9IFtwYXRoLnBhcnRzLmpvaW4oJy8nKV07XG4gICAgfSBlbHNlIGlmIChvcmlnaW5hbCA9PT0gJy4nKSB7XG4gICAgICBsZXQgbG9jYXRpb25JbmZvID0gYEwke2xvYy5zdGFydC5saW5lfTpDJHtsb2Muc3RhcnQuY29sdW1ufWA7XG4gICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXG4gICAgICAgIGAnLicgaXMgbm90IGEgc3VwcG9ydGVkIHBhdGggaW4gR2xpbW1lcjsgY2hlY2sgZm9yIGEgcGF0aCB3aXRoIGEgdHJhaWxpbmcgJy4nIGF0ICR7bG9jYXRpb25JbmZvfS5gLFxuICAgICAgICBwYXRoLmxvY1xuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGFydHMgPSBwYXRoLnBhcnRzO1xuICAgIH1cblxuICAgIGxldCB0aGlzSGVhZCA9IGZhbHNlO1xuXG4gICAgLy8gVGhpcyBpcyB0byBmaXggYSBidWcgaW4gdGhlIEhhbmRsZWJhcnMgQVNUIHdoZXJlIHRoZSBwYXRoIGV4cHJlc3Npb25zIGluXG4gICAgLy8gYHt7dGhpcy5mb299fWAgKGFuZCBzaW1pbGFybHkgYHt7Zm9vLWJhciB0aGlzLmZvbyBuYW1lZD10aGlzLmZvb319YCBldGMpXG4gICAgLy8gYXJlIHNpbXBseSB0dXJuZWQgaW50byBge3tmb299fWAuIFRoZSBmaXggaXMgdG8gcHVzaCBpdCBiYWNrIG9udG8gdGhlXG4gICAgLy8gcGFydHMgYXJyYXkgYW5kIGxldCB0aGUgcnVudGltZSBzZWUgdGhlIGRpZmZlcmVuY2UuIEhvd2V2ZXIsIHdlIGNhbm5vdFxuICAgIC8vIHNpbXBseSB1c2UgdGhlIHN0cmluZyBgdGhpc2AgYXMgaXQgbWVhbnMgbGl0ZXJhbGx5IHRoZSBwcm9wZXJ0eSBjYWxsZWRcbiAgICAvLyBcInRoaXNcIiBpbiB0aGUgY3VycmVudCBjb250ZXh0IChpdCBjYW4gYmUgZXhwcmVzc2VkIGluIHRoZSBzeW50YXggYXNcbiAgICAvLyBge3tbdGhpc119fWAsIHdoZXJlIHRoZSBzcXVhcmUgYnJhY2tldCBhcmUgZ2VuZXJhbGx5IGZvciB0aGlzIGtpbmQgb2ZcbiAgICAvLyBlc2NhcGluZyDigJMgc3VjaCBhcyBge3tmb28uW1wiYmFyLmJhelwiXX19YCB3b3VsZCBtZWFuIGxvb2t1cCBhIHByb3BlcnR5XG4gICAgLy8gbmFtZWQgbGl0ZXJhbGx5IFwiYmFyLmJhelwiIG9uIGB0aGlzLmZvb2ApLiBCeSBjb252ZW50aW9uLCB3ZSB1c2UgYG51bGxgXG4gICAgLy8gZm9yIHRoaXMgcHVycG9zZS5cbiAgICBpZiAob3JpZ2luYWwubWF0Y2goL150aGlzKFxcLi4rKT8kLykpIHtcbiAgICAgIHRoaXNIZWFkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogJ1BhdGhFeHByZXNzaW9uJyxcbiAgICAgIG9yaWdpbmFsOiBwYXRoLm9yaWdpbmFsLFxuICAgICAgdGhpczogdGhpc0hlYWQsXG4gICAgICBwYXJ0cyxcbiAgICAgIGRhdGE6IHBhdGguZGF0YSxcbiAgICAgIGxvYzogcGF0aC5sb2MsXG4gICAgfTtcbiAgfVxuXG4gIEhhc2goaGFzaDogSEJTLkhhc2gpOiBBU1QuSGFzaCB7XG4gICAgbGV0IHBhaXJzOiBBU1QuSGFzaFBhaXJbXSA9IFtdO1xuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBoYXNoLnBhaXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsZXQgcGFpciA9IGhhc2gucGFpcnNbaV07XG4gICAgICBwYWlycy5wdXNoKGIucGFpcihwYWlyLmtleSwgdGhpcy5hY2NlcHROb2RlKHBhaXIudmFsdWUpLCBwYWlyLmxvYykpO1xuICAgIH1cblxuICAgIHJldHVybiBiLmhhc2gocGFpcnMsIGhhc2gubG9jKTtcbiAgfVxuXG4gIFN0cmluZ0xpdGVyYWwoc3RyaW5nOiBIQlMuU3RyaW5nTGl0ZXJhbCk6IEFTVC5TdHJpbmdMaXRlcmFsIHtcbiAgICByZXR1cm4gYi5saXRlcmFsKCdTdHJpbmdMaXRlcmFsJywgc3RyaW5nLnZhbHVlLCBzdHJpbmcubG9jKTtcbiAgfVxuXG4gIEJvb2xlYW5MaXRlcmFsKGJvb2xlYW46IEhCUy5Cb29sZWFuTGl0ZXJhbCk6IEFTVC5Cb29sZWFuTGl0ZXJhbCB7XG4gICAgcmV0dXJuIGIubGl0ZXJhbCgnQm9vbGVhbkxpdGVyYWwnLCBib29sZWFuLnZhbHVlLCBib29sZWFuLmxvYyk7XG4gIH1cblxuICBOdW1iZXJMaXRlcmFsKG51bWJlcjogSEJTLk51bWJlckxpdGVyYWwpOiBBU1QuTnVtYmVyTGl0ZXJhbCB7XG4gICAgcmV0dXJuIGIubGl0ZXJhbCgnTnVtYmVyTGl0ZXJhbCcsIG51bWJlci52YWx1ZSwgbnVtYmVyLmxvYyk7XG4gIH1cblxuICBVbmRlZmluZWRMaXRlcmFsKHVuZGVmOiBIQlMuVW5kZWZpbmVkTGl0ZXJhbCk6IEFTVC5VbmRlZmluZWRMaXRlcmFsIHtcbiAgICByZXR1cm4gYi5saXRlcmFsKCdVbmRlZmluZWRMaXRlcmFsJywgdW5kZWZpbmVkLCB1bmRlZi5sb2MpO1xuICB9XG5cbiAgTnVsbExpdGVyYWwobnVsOiBIQlMuTnVsbExpdGVyYWwpOiBBU1QuTnVsbExpdGVyYWwge1xuICAgIHJldHVybiBiLmxpdGVyYWwoJ051bGxMaXRlcmFsJywgbnVsbCwgbnVsLmxvYyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2FsY3VsYXRlUmlnaHRTdHJpcHBlZE9mZnNldHMob3JpZ2luYWw6IHN0cmluZywgdmFsdWU6IHN0cmluZykge1xuICBpZiAodmFsdWUgPT09ICcnKSB7XG4gICAgLy8gaWYgaXQgaXMgZW1wdHksIGp1c3QgcmV0dXJuIHRoZSBjb3VudCBvZiBuZXdsaW5lc1xuICAgIC8vIGluIG9yaWdpbmFsXG4gICAgcmV0dXJuIHtcbiAgICAgIGxpbmVzOiBvcmlnaW5hbC5zcGxpdCgnXFxuJykubGVuZ3RoIC0gMSxcbiAgICAgIGNvbHVtbnM6IDAsXG4gICAgfTtcbiAgfVxuXG4gIC8vIG90aGVyd2lzZSwgcmV0dXJuIHRoZSBudW1iZXIgb2YgbmV3bGluZXMgcHJpb3IgdG9cbiAgLy8gYHZhbHVlYFxuICBsZXQgZGlmZmVyZW5jZSA9IG9yaWdpbmFsLnNwbGl0KHZhbHVlKVswXTtcbiAgbGV0IGxpbmVzID0gZGlmZmVyZW5jZS5zcGxpdCgvXFxuLyk7XG4gIGxldCBsaW5lQ291bnQgPSBsaW5lcy5sZW5ndGggLSAxO1xuXG4gIHJldHVybiB7XG4gICAgbGluZXM6IGxpbmVDb3VudCxcbiAgICBjb2x1bW5zOiBsaW5lc1tsaW5lQ291bnRdLmxlbmd0aCxcbiAgfTtcbn1cblxuZnVuY3Rpb24gdXBkYXRlVG9rZW5pemVyTG9jYXRpb24odG9rZW5pemVyOiBQYXJzZXJbJ3Rva2VuaXplciddLCBjb250ZW50OiBIQlMuQ29udGVudFN0YXRlbWVudCkge1xuICBsZXQgbGluZSA9IGNvbnRlbnQubG9jLnN0YXJ0LmxpbmU7XG4gIGxldCBjb2x1bW4gPSBjb250ZW50LmxvYy5zdGFydC5jb2x1bW47XG5cbiAgbGV0IG9mZnNldHMgPSBjYWxjdWxhdGVSaWdodFN0cmlwcGVkT2Zmc2V0cyhcbiAgICBjb250ZW50Lm9yaWdpbmFsIGFzIFJlY2FzdDxIQlMuU3RyaXBGbGFncywgc3RyaW5nPixcbiAgICBjb250ZW50LnZhbHVlXG4gICk7XG5cbiAgbGluZSA9IGxpbmUgKyBvZmZzZXRzLmxpbmVzO1xuICBpZiAob2Zmc2V0cy5saW5lcykge1xuICAgIGNvbHVtbiA9IG9mZnNldHMuY29sdW1ucztcbiAgfSBlbHNlIHtcbiAgICBjb2x1bW4gPSBjb2x1bW4gKyBvZmZzZXRzLmNvbHVtbnM7XG4gIH1cblxuICB0b2tlbml6ZXIubGluZSA9IGxpbmU7XG4gIHRva2VuaXplci5jb2x1bW4gPSBjb2x1bW47XG59XG5cbmZ1bmN0aW9uIGFjY2VwdENhbGxOb2RlcyhcbiAgY29tcGlsZXI6IEhhbmRsZWJhcnNOb2RlVmlzaXRvcnMsXG4gIG5vZGU6IHtcbiAgICBwYXRoOiBIQlMuUGF0aEV4cHJlc3Npb247XG4gICAgcGFyYW1zOiBIQlMuRXhwcmVzc2lvbltdO1xuICAgIGhhc2g6IEhCUy5IYXNoO1xuICB9XG4pOiB7IHBhdGg6IEFTVC5QYXRoRXhwcmVzc2lvbjsgcGFyYW1zOiBBU1QuRXhwcmVzc2lvbltdOyBoYXNoOiBBU1QuSGFzaCB9IHtcbiAgbGV0IHBhdGggPSBjb21waWxlci5QYXRoRXhwcmVzc2lvbihub2RlLnBhdGgpO1xuXG4gIGxldCBwYXJhbXMgPSBub2RlLnBhcmFtcyA/IG5vZGUucGFyYW1zLm1hcChlID0+IGNvbXBpbGVyLmFjY2VwdE5vZGU8QVNULkV4cHJlc3Npb24+KGUpKSA6IFtdO1xuICBsZXQgaGFzaCA9IG5vZGUuaGFzaCA/IGNvbXBpbGVyLkhhc2gobm9kZS5oYXNoKSA6IGIuaGFzaCgpO1xuXG4gIHJldHVybiB7IHBhdGgsIHBhcmFtcywgaGFzaCB9O1xufVxuXG5mdW5jdGlvbiBhZGRFbGVtZW50TW9kaWZpZXIoZWxlbWVudDogVGFnPCdTdGFydFRhZyc+LCBtdXN0YWNoZTogQVNULk11c3RhY2hlU3RhdGVtZW50KSB7XG4gIGxldCB7IHBhdGgsIHBhcmFtcywgaGFzaCwgbG9jIH0gPSBtdXN0YWNoZTtcblxuICBpZiAoaXNMaXRlcmFsKHBhdGgpKSB7XG4gICAgbGV0IG1vZGlmaWVyID0gYHt7JHtwcmludExpdGVyYWwocGF0aCl9fX1gO1xuICAgIGxldCB0YWcgPSBgPCR7ZWxlbWVudC5uYW1lfSAuLi4gJHttb2RpZmllcn0gLi4uYDtcblxuICAgIHRocm93IG5ldyBTeW50YXhFcnJvcihcbiAgICAgIGBJbiAke3RhZ30sICR7bW9kaWZpZXJ9IGlzIG5vdCBhIHZhbGlkIG1vZGlmaWVyOiBcIiR7cGF0aC5vcmlnaW5hbH1cIiBvbiBsaW5lICR7bG9jICYmXG4gICAgICAgIGxvYy5zdGFydC5saW5lfS5gLFxuICAgICAgbXVzdGFjaGUubG9jXG4gICAgKTtcbiAgfVxuXG4gIGxldCBtb2RpZmllciA9IGIuZWxlbWVudE1vZGlmaWVyKHBhdGgsIHBhcmFtcywgaGFzaCwgbG9jKTtcbiAgZWxlbWVudC5tb2RpZmllcnMucHVzaChtb2RpZmllcik7XG59XG5cbmZ1bmN0aW9uIGFkZEluRWxlbWVudEhhc2goY3Vyc29yOiBzdHJpbmcsIGhhc2g6IEFTVC5IYXNoLCBsb2M6IEFTVC5Tb3VyY2VMb2NhdGlvbikge1xuICBsZXQgaGFzSW5zZXJ0QmVmb3JlID0gZmFsc2U7XG4gIGhhc2gucGFpcnMuZm9yRWFjaChwYWlyID0+IHtcbiAgICBpZiAocGFpci5rZXkgPT09ICdndWlkJykge1xuICAgICAgdGhyb3cgbmV3IFN5bnRheEVycm9yKCdDYW5ub3QgcGFzcyBgZ3VpZGAgZnJvbSB1c2VyIHNwYWNlJywgbG9jKTtcbiAgICB9XG5cbiAgICBpZiAocGFpci5rZXkgPT09ICdpbnNlcnRCZWZvcmUnKSB7XG4gICAgICBoYXNJbnNlcnRCZWZvcmUgPSB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbiAgbGV0IGd1aWQgPSBiLmxpdGVyYWwoJ1N0cmluZ0xpdGVyYWwnLCBjdXJzb3IpO1xuICBsZXQgZ3VpZFBhaXIgPSBiLnBhaXIoJ2d1aWQnLCBndWlkKTtcbiAgaGFzaC5wYWlycy51bnNoaWZ0KGd1aWRQYWlyKTtcblxuICBpZiAoIWhhc0luc2VydEJlZm9yZSkge1xuICAgIGxldCB1bmRlZmluZWRMaXRlcmFsID0gYi5saXRlcmFsKCdVbmRlZmluZWRMaXRlcmFsJywgdW5kZWZpbmVkKTtcbiAgICBsZXQgYmVmb3JlU2libGluZyA9IGIucGFpcignaW5zZXJ0QmVmb3JlJywgdW5kZWZpbmVkTGl0ZXJhbCk7XG4gICAgaGFzaC5wYWlycy5wdXNoKGJlZm9yZVNpYmxpbmcpO1xuICB9XG5cbiAgcmV0dXJuIGhhc2g7XG59XG5cbmZ1bmN0aW9uIGFwcGVuZER5bmFtaWNBdHRyaWJ1dGVWYWx1ZVBhcnQoYXR0cmlidXRlOiBBdHRyaWJ1dGUsIHBhcnQ6IEFTVC5NdXN0YWNoZVN0YXRlbWVudCkge1xuICBhdHRyaWJ1dGUuaXNEeW5hbWljID0gdHJ1ZTtcbiAgYXR0cmlidXRlLnBhcnRzLnB1c2gocGFydCk7XG59XG4iXSwic291cmNlUm9vdCI6IiJ9